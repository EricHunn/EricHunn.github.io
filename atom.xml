<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无心是一首歌</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://erichunn.github.io/"/>
  <updated>2019-11-06T15:21:30.994Z</updated>
  <id>http://erichunn.github.io/</id>
  
  <author>
    <name>Eric Hunn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Oracle使用</title>
    <link href="http://erichunn.github.io/2019/11/06/Oracle%E4%BD%BF%E7%94%A8/"/>
    <id>http://erichunn.github.io/2019/11/06/Oracle使用/</id>
    <published>2019-11-06T06:18:03.000Z</published>
    <updated>2019-11-06T15:21:30.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle的查询"><a href="#Oracle的查询" class="headerlink" title="Oracle的查询"></a>Oracle的查询</h1><h2 id="单行查询"><a href="#单行查询" class="headerlink" title="单行查询"></a>单行查询</h2><p>upper代表将小写转换成大写，lower大写变小写<br><img src="https://i.imgur.com/9rodKEr.png" alt=""><br>round四舍五入，后面参数保留几位。trunc直接截取几位。<br><img src="https://i.imgur.com/s5tOMWq.png" alt=""></p><p><img src="https://i.imgur.com/xxDaXwf.png" alt=""></p><p><img src="https://i.imgur.com/NKM9KU5.png" alt=""></p><p>转换函数：<br><img src="https://i.imgur.com/3lGMivQ.png" alt=""><br>通用函数：<br>nvl函数：如果是空的话就按照后面的给定的数值来计算：<br><img src="https://i.imgur.com/D1Zlr9D.png" alt=""></p><h2 id="多行函数（聚合函数）"><a href="#多行函数（聚合函数）" class="headerlink" title="多行函数（聚合函数）"></a>多行函数（聚合函数）</h2><p><img src="https://i.imgur.com/ZWGzcWn.png" alt=""></p><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p>分组查询中，出现在group by后面的原始列才能出现在select后面 ，没有出现在group by后面的列想在select后面出现必须加上聚合函数，也就是下面的e.sal必须要使用完聚合函数之后才能用。下面这个SQL在经历了group by之后已经变成了三行两列的状况，也就是有几个部门就有几组数据了。所以如果在聚合完了之后的再去查询e.ename，一个部门肯定不止一个人，怎么都没法查询，所以说select后面出现的必须是一个组的共同特性。<br>聚合函数是作用于多列返回一个值，也就是聚合函数有一个特性，可以把多行记录变成一个值。<br><img src="https://i.imgur.com/pZd41xt.png" alt=""></p><hr><p>如果说把avg(e.sal) 设置一个别名asal那么在写having条件的时候能否直接使用asal&gt;200呢，不行的</p><p>所有条件都不能使用别名判断，因为在查询的时候都是分先后顺序的。<br><img src="https://i.imgur.com/vs8YqkY.png" alt=""></p><hr><p>说一个错误的案例<br><img src="https://i.imgur.com/KazK8Dz.png" alt=""></p><hr><p><img src="https://i.imgur.com/4A7O1hp.png" alt=""></p><p><img src="https://i.imgur.com/oa1LRqq.png" alt=""></p><hr><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p><img src="https://i.imgur.com/pRhtP3Z.png" alt=""></p><p>内连接和等值连接一样</p><p><img src="https://i.imgur.com/9PJPFNT.png" alt=""></p><p><img src="https://i.imgur.com/ER5WivO.png" alt=""></p><p><img src="https://i.imgur.com/xH8YnZX.png" alt=""></p><h3 id="左外连接和右外连接的区别"><a href="#左外连接和右外连接的区别" class="headerlink" title="左外连接和右外连接的区别"></a>左外连接和右外连接的区别</h3><p><img src="https://i.imgur.com/39ZdRfn.png" alt=""></p><h3 id="oracle中专用连接"><a href="#oracle中专用连接" class="headerlink" title="oracle中专用连接"></a>oracle中专用连接</h3><p><img src="https://i.imgur.com/4XxzU1B.png" alt=""></p><hr><h3 id="继续多表查询"><a href="#继续多表查询" class="headerlink" title="继续多表查询"></a>继续多表查询</h3><p>首先如果写一个复杂的查询先把架子搭起来，也就是：</p><p>select </p><p>from </p><p>where</p><p>然后在继续往里面写<br><img src="https://i.imgur.com/hL5Scyy.png" alt=""></p><p>首先看上面这张图，要写这个SQL首先考虑员工在哪一张表，领导姓名在哪张表，然后放在from后面</p><p>首先这个数据库下EMP表可以看到多个信息，可以看见员工也可以看见这个员工对应的领导</p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p><img src="https://i.imgur.com/Rt47x0M.png" alt=""><br>其中mgr是领导编号，empno是员工编号</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>下面这个查询的前提是这个ename是主键，也就是唯一可以写等号<br><img src="https://i.imgur.com/gDwL9BT.png" alt=""></p><p>要不然下面这种写法比较准确</p><p><img src="https://i.imgur.com/Wc2Ovse.png" alt=""></p><hr><p><img src="https://i.imgur.com/7LZ8JtO.png" alt=""></p><hr><p><img src="https://i.imgur.com/c5IfG9S.png" alt=""></p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p><img src="https://i.imgur.com/rGa4WDi.png" alt=""></p><p>这个分页查询的仔细解释，涉及到一个rownum的问题。</p><p>首先看下面这样一个错误的案例：下面这个错误的案例的原因是由于顺序的问题首先是select 的内容，做完之后rownum就是在select之后就排序了，这个rownum也就相当于一个独立于这个表之外的一个列的感觉。这样的话然后再去使用where条件的话rownum已经是乱序的了，所以，这样的话是拿不到前几个的</p><p><img src="https://i.imgur.com/VJc7HGK.png" alt=""></p><p>那么rownum乱序怎么理解呢？看如下图，也就是说上面的where条件是在下面这种情况下加上的。</p><p><img src="https://i.imgur.com/Ik1OhOt.png" alt=""></p><p>所以得出来一个结论，也就是排序操作会影响rownum的顺序，我们可以先排序在去加行号。</p><p><img src="https://i.imgur.com/vRYDkdp.png" alt=""></p><p>这样就已经不乱了。</p><p>也就是说如果涉及到排序，但是还需要使用rownum的话，我们可以再次嵌套查询，就可以避开rownum乱的顺序了。</p><p>接着来说分页查询的一个失败的案例</p><p><img src="https://i.imgur.com/9AJibTN.png" alt=""></p><p>看上面的这个发现这样子查询出来就一条数据都没有了，什么原因呢</p><p>原因就是因为rownum是在select之后按照顺序排列的，rownum是按照顺序依次递增不能跳着顺序走。那么这句SQL就设计到一个问题，也就是select先执行还是where先执行的问题。我们知道是where先走，当where先的时候，查询第一条记录本来要在该记录上加上一个行号1但是一看要通过rownum=1来判断rownum&gt;5的条件，这样一来怎么都不能满足，第一个rownum就加不上，也不能跳跃着加，所以就查不到了，只不过是条件不满足而已。</p><p>所以rownum不能直接写大于一个正数，但是我们可以通过嵌套间接写大于也就是如下</p><p><img src="https://i.imgur.com/T7okHNi.png" alt=""></p><p>分页查询结束</p><hr><hr><hr><h1 id="Oracle的对象"><a href="#Oracle的对象" class="headerlink" title="Oracle的对象"></a>Oracle的对象</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><img src="https://i.imgur.com/RTT3Y5W.png" alt=""></p><p><img src="https://i.imgur.com/ZKixbfN.png" alt=""></p><p><img src="https://i.imgur.com/LNbrv3z.png" alt=""></p><p>假如总部一个查询语句，分部一个查询语句各自查一套，总部突然卖出了十万雨伞，但是分部没有及时去查询，就出现总部已经没货了，所以就让总部从表中查询，分部看视图，因为视图里面根本就没数据，只要总部的数据改变了，分部立马就能看到最新的数据。这是视图经常使用的地方。</p><hr><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="https://i.imgur.com/oEGbq9z.png" alt=""></p><p><img src="https://i.imgur.com/dgIVAcY.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oracle的查询&quot;&gt;&lt;a href=&quot;#Oracle的查询&quot; class=&quot;headerlink&quot; title=&quot;Oracle的查询&quot;&gt;&lt;/a&gt;Oracle的查询&lt;/h1&gt;&lt;h2 id=&quot;单行查询&quot;&gt;&lt;a href=&quot;#单行查询&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC第二天</title>
    <link href="http://erichunn.github.io/2019/11/03/SpringMVC%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>http://erichunn.github.io/2019/11/03/SpringMVC第二天/</id>
    <published>2019-11-03T13:06:07.000Z</published>
    <updated>2019-11-06T03:43:45.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：相应数据和结果视图"><a href="#第一章：相应数据和结果视图" class="headerlink" title="第一章：相应数据和结果视图"></a>第一章：相应数据和结果视图</h1><h2 id="响应之返回值是String类型的"><a href="#响应之返回值是String类型的" class="headerlink" title="响应之返回值是String类型的"></a>响应之返回值是String类型的</h2><blockquote><p>首先说一个以后开发常见的方式：<br>首先从response.jsp发请求，然后我从Controller后台查出来，存到model，存到request里，然后在转发到页面。再从request域里取出来。</p></blockquote><pre><code>package cn.itcast.controller;import cn.itcast.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/** * @Description TODO * @Author TT Hun * @Data 2019/11/3 21:26 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    @RequestMapping(&quot;/testString&quot;)    public String testString(Model model){        System.out.println(&quot;testString方法执行了...&quot;);//       模拟从数据库中查询对象        User user = new User();        user.setUsername(&quot;美美&quot;);        user.setPassword(&quot;123&quot;);        user.setAge(30);//        把对象存起来        model.addAttribute(&quot;user&quot;,user);        return &quot;success&quot;;    }}</code></pre><hr><pre><code>package cn.itcast.domain;import java.io.Serializable;/** * @Description TODO * @Author TT Hun * @Data 2019/11/3 22:00 */public class User  implements Serializable {    private String password;    private Integer age;    private String  username;    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }}</code></pre><hr><p>springmvc.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 开启注解扫描 扫描这个路径下的包，就可以在--&gt;    &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;    &lt;!-- 视图解析器对象  视图解析器的类名是固定的，然后配置通过这个视图解析器就可以让controller里面return的东西直接跳转指定的jsp页面        但是还需要配置2个属性，一个是Prefix就是配置找文件的路径        suffix指的是配置的后缀名字。最后也就是找/web-if/pages/下的后缀是jsp的文件--&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 开启SpringMVC框架注解的支持 标签是固定的--&gt;    &lt;mvc:annotation-driven  /&gt;&lt;/beans&gt;</code></pre><hr><p>success.jsp</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 21:22  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;执行成功&lt;/h2&gt;${user.username}${user.password}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>web.xml</p><pre><code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--配置前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--配置解决中文乱码的过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 21:25  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;user/testString&quot; &gt;testString&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><hr><hr><h2 id="响应值值返回值是void类型"><a href="#响应值值返回值是void类型" class="headerlink" title="响应值值返回值是void类型"></a>响应值值返回值是void类型</h2><h3 id="第一种方法：编写请求转发程序跳转到jsp界面"><a href="#第一种方法：编写请求转发程序跳转到jsp界面" class="headerlink" title="第一种方法：编写请求转发程序跳转到jsp界面"></a>第一种方法：编写请求转发程序跳转到jsp界面</h3><pre><code>package cn.itcast.controller;import cn.itcast.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @Description TODO * @Author TT Hun * @Data 2019/11/3 21:26 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    /**     * 返回值类型是一个字符串     * @param model     * @return     */    @RequestMapping(&quot;/testString&quot;)    public String testString(Model model){        System.out.println(&quot;testString方法执行了...&quot;);//       模拟从数据库中查询对象        User user = new User();        user.setUsername(&quot;美美&quot;);        user.setPassword(&quot;123&quot;);        user.setAge(30);//        把对象存起来        model.addAttribute(&quot;user&quot;,user);        return &quot;success&quot;;    }    /**     * 返回值类型是Void     * 请求转发是一次请求，请求路径不用编写项目名字     * @param     * @return     */    @RequestMapping(&quot;/testVoid&quot;)    public void testVoid(HttpServletRequest request ,HttpServletResponse response)throws  Exception{        System.out.println(&quot;testVoid方法执行了...&quot;);//       便携请求转发的程序，手动便携转发程序不会通过视图解析器，所以要自己配置WEB-INF/pages/success.jsp需要自己提供完整目录        request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request,response);        return ;    }}</code></pre><hr><pre><code>package cn.itcast.domain;import java.io.Serializable;/** * @Description TODO * @Author TT Hun * @Data 2019/11/3 22:00 */public class User  implements Serializable {    private String password;    private Integer age;    private String  username;    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }}</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 21:25  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;user/testString&quot; &gt;testString&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;user/testVoid&quot;&gt;testVoid&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>success.jsp</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 21:22  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;执行成功&lt;/h2&gt;${user.username}${user.password}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h3 id="第二种方法：重定向"><a href="#第二种方法：重定向" class="headerlink" title="第二种方法：重定向"></a>第二种方法：重定向</h3><p><img src="https://i.imgur.com/JKmwTno.png" alt=""></p><h3 id="第三种方法：直接响应"><a href="#第三种方法：直接响应" class="headerlink" title="第三种方法：直接响应"></a>第三种方法：直接响应</h3><p><img src="https://i.imgur.com/nqn2Zb5.png" alt=""></p><hr><h2 id="响应之返回值是ModelAndView类型"><a href="#响应之返回值是ModelAndView类型" class="headerlink" title="响应之返回值是ModelAndView类型"></a>响应之返回值是ModelAndView类型</h2><p>这个和返回值是String基本是一样的，只不过写法不同，返回值String底层也是调用这个的。<br><img src="https://i.imgur.com/cRzAOZk.png" alt=""></p><h2 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h2><p>有个问题没搞懂，重定向智能定位到根目录下的文件吗。为什么写和上面一样的路径不能跳转。是一个问题，尚未认真考虑解决呢。<br><img src="https://i.imgur.com/3qS26c7.png" alt=""></p><h2 id="ResponseBody注解响应json数据"><a href="#ResponseBody注解响应json数据" class="headerlink" title="ResponseBody注解响应json数据"></a>ResponseBody注解响应json数据</h2><p>页面发送一个axis请求，是一个异步请求，后台需要把对象转换成json的字符串响应回去可以通过ResponseBody这个注解完成这个任务。</p><p>这个地方需要告诉前端控制器不是所有请求都拦截的，静态资源比如.js和图片是不需要拦截的。下面这地方配置为/证明都拦截还需要在springmvc.xml中配置哪些不拦截<br><img src="https://i.imgur.com/R7peaUO.png" alt=""><br><img src="https://i.imgur.com/2pkeXim.png" alt=""></p><p>先看目录结构：<br><img src="https://i.imgur.com/DqJvvYs.png" alt="">里面的js文件视频中是从资料中直接拿到的。</p><p>下面是整个代码的结构：</p><p><img src="https://i.imgur.com/XvHH7N4.png" alt=""></p><p>response.jsp界面</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 21:25  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;%--下面这个是吧js引入到了jsp里面了--%&gt;    &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        // 页面加载，绑定点击时间        $(function(){            $(&quot;#btn&quot;).click(function(){                 alert(&quot;hello btn&quot;);            });        });    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;user/testString&quot; &gt;testString&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;user/testVoid&quot;&gt;testVoid&lt;/a&gt;5&lt;br&gt;&lt;%--转发或者重定向--%&gt;&lt;a href=&quot;user/testForwardOrRedirect&quot;&gt;testForwardOrRedirect&lt;/a&gt;&lt;%--写一个按钮--%&gt;&lt;button id=&quot;btn&quot;&gt;发送ajax的请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>在springmvc.xml文件中设置哪些不拦截；</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 开启注解扫描 扫描这个路径下的包，就可以在--&gt;    &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;    &lt;!-- 视图解析器对象  视图解析器的类名是固定的，然后配置通过这个视图解析器就可以让controller里面return的东西直接跳转指定的jsp页面        但是还需要配置2个属性，一个是Prefix就是配置找文件的路径        suffix指的是配置的后缀名字。最后也就是找/web-if/pages/下的后缀是jsp的文件--&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;!--前端控制器，哪些静态资源不拦截，location写法就是以后js下所有的请求都不拦截，mapping就是和映射请求有关的,以后jss-图片也需要配置上不拦截--&gt;    &lt;mvc:resources mapping=&quot;/js/&quot; location=&quot;/js/**&quot;/&gt;&lt;!--     开启SpringMVC框架注解的支持 标签是固定的--&gt;    &lt;mvc:annotation-driven  /&gt;&lt;/beans&gt;</code></pre><hr><h2 id="响应json数据之发送ajax请求"><a href="#响应json数据之发送ajax请求" class="headerlink" title="响应json数据之发送ajax请求"></a>响应json数据之发送ajax请求</h2><p>package cn.itcast.controller;</p><p>import cn.itcast.domain.User;<br>import org.springframework.stereotype.Controller;<br>import org.springframework.ui.Model;<br>import org.springframework.web.bind.annotation.RequestBody;<br>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.servlet.ModelAndView;</p><p>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p><p>/**</p><ul><li>@Description TODO</li><li>@Author TT Hun</li><li><p>@Data 2019/11/3 21:26<br>*/<br>@Controller<br>@RequestMapping(“/user”)<br>public class UserController {</p><p> /**</p><ul><li>模拟异步请求和响应过程</li><li>@param</li><li>@return<br>*/<br>@RequestMapping(“/testAjax”)<br>public void testAjax(@RequestBody String body){<br> System.out.println(“testForwardOrRedirect开始执行”);<br> System.out.println(body);<br>}<br>}</li></ul></li></ul><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 21:25  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;%--下面这个是吧js引入到了jsp里面了--%&gt;    &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        // 页面加载，绑定点击时间        $(function(){            $(&quot;#btn&quot;).click(function(){                 // alert(&quot;hello btn&quot;);            //    发送ajax请求                $.ajax({                //    编写json格式                    url:&quot;user/testAjax&quot;,                    //给服务器端传递的类型                    contentType:&quot;application/json;charset=utf-8&quot;,                    data:&apos;{&quot;username&quot;:&quot;呵呵&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:&quot;30&quot;}&apos;,                    dataType:&quot;json&quot;,                    type:&quot;post&quot;,                    success:function (data){                //        data指的是服务器端Json相应的数据，进行解析                }                })            });        });    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;user/testString&quot; &gt;testString&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;user/testVoid&quot;&gt;testVoid&lt;/a&gt;5&lt;br&gt;&lt;%--转发或者重定向--%&gt;&lt;a href=&quot;user/testForwardOrRedirect&quot;&gt;testForwardOrRedirect&lt;/a&gt;&lt;%--写一个按钮--%&gt;&lt;button id=&quot;btn&quot;&gt;发送ajax的请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>结果直接拿到请求体<br><img src="https://i.imgur.com/Fm5iLrw.png" alt=""></p><hr><h3 id="怎么返回的json数据直接封装到对象当中"><a href="#怎么返回的json数据直接封装到对象当中" class="headerlink" title="怎么返回的json数据直接封装到对象当中"></a>怎么返回的json数据直接封装到对象当中</h3><p> springmvc框架已经帮我们做好了很多，如果Key和javabean中属性相同，可以直接封装到javabean里面，但是需要额外的jar包做类型转换。把串转成对象或者把对象转成串。</p><pre><code>package cn.itcast.controller;import cn.itcast.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @Description TODO * @Author TT Hun * @Data 2019/11/3 21:26 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    @RequestMapping(&quot;/testAjax&quot;)    public @ResponseBody User testAjax(@RequestBody User user){        System.out.println(&quot;testAjax开始执行&quot;);//       客户端发送的ajax请求，传递的是json字符串，后台已经把字符串封装到user对象当中去了        System.out.println(user);//        做一个响应        user.setUsername(&quot;哈哈&quot;);        user.setAge(40);        user.setPassword(&quot;123&quot;);        return user;    }}</code></pre><hr><pre><code>package cn.itcast.domain;import java.io.Serializable;/** * @Description TODO * @Author TT Hun * @Data 2019/11/3 22:00 */public class User  implements Serializable {    private String password;    private Integer age;    private String  username;    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;password=&apos;&quot; + password + &apos;\&apos;&apos; +                &quot;, age=&quot; + age +                &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; +                &apos;}&apos;;    }}</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 21:25  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;%--下面这个是吧js引入到了jsp里面了--%&gt;    &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        // 页面加载，绑定点击时间        $(function(){            $(&quot;#btn&quot;).click(function(){                 // alert(&quot;hello btn&quot;);            //    发送ajax请求                $.ajax({                //    编写json格式                    url:&quot;user/testAjax&quot;,                    //给服务器端传递的类型                    contentType:&quot;application/json;charset=utf-8&quot;,                    data:&apos;{&quot;username&quot;:&quot;呵呵&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:&quot;30&quot;}&apos;,                    dataType:&quot;json&quot;,                    type:&quot;post&quot;,                    success:function (data){                //        data指的是服务器端Json相应的数据，进行解析                    alert(data);                    alert(data.username);                    alert(data.age);                    alert(data.password);                }                })            });        });    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;user/testString&quot; &gt;testString&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;user/testVoid&quot;&gt;testVoid&lt;/a&gt;5&lt;br&gt;&lt;%--转发或者重定向--%&gt;&lt;a href=&quot;user/testForwardOrRedirect&quot;&gt;testForwardOrRedirect&lt;/a&gt;&lt;%--写一个按钮--%&gt;&lt;button id=&quot;btn&quot;&gt;发送ajax的请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p><img src="https://i.imgur.com/qJnIJQ4.png" alt=""></p><h1 id="第二章：SpringMVC实现文件上传"><a href="#第二章：SpringMVC实现文件上传" class="headerlink" title="第二章：SpringMVC实现文件上传"></a>第二章：SpringMVC实现文件上传</h1><h2 id="文件上传回顾"><a href="#文件上传回顾" class="headerlink" title="文件上传回顾"></a>文件上传回顾</h2><p>默认表单提交数据的格式是一组键值对的方式username=hehe&amp;password=123但是一旦把取值从默认变成multipart会把提交的表单分成几个部分，里面存储数据，可能包含文本框的值也可能包含上传选择文件的内容。<br><img src="https://i.imgur.com/3UI4KKM.png" alt=""></p><p>然后请求正文的内容变成：<br><img src="https://i.imgur.com/WUaN9Pk.png" alt=""><br><img src="https://i.imgur.com/koETv8W.png" alt=""></p><p>这时候表单用分隔符的方式把它分成了若干个部分。那么怎么去解析呢？通过一个jar包的组件<br><img src="https://i.imgur.com/eZ3Pu31.png" alt=""></p><hr><h2 id="首先环境搭建"><a href="#首先环境搭建" class="headerlink" title="首先环境搭建"></a>首先环境搭建</h2><p>配置springmvc.xml配置web.xml配置Pom.xml</p><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- $Id: pom.xml 642118 2008-03-28 08:04:16Z reinhard $ --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;springmvc_day02_02_fileupload&lt;/name&gt;  &lt;groupId&gt;cn.itcast&lt;/groupId&gt;  &lt;artifactId&gt;springmvc_day02_02_fileupload&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;  &lt;/properties&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;        &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;        &lt;version&gt;6.1.7&lt;/version&gt;        &lt;configuration&gt;          &lt;connectors&gt;            &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;              &lt;port&gt;8888&lt;/port&gt;              &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt;            &lt;/connector&gt;          &lt;/connectors&gt;          &lt;webAppSourceDirectory&gt;${project.build.directory}/${pom.artifactId}-${pom.version}&lt;/webAppSourceDirectory&gt;          &lt;contextPath&gt;/&lt;/contextPath&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;      &lt;version&gt;2.5&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;      &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;      &lt;version&gt;1.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-io&lt;/groupId&gt;      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;      &lt;version&gt;2.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;      &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;      &lt;version&gt;2.0&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/project&gt;</code></pre><hr><p>web.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.4&quot;         xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;  &lt;!--配置前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--配置解决中文乱码的过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><hr><p>springmvc.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 开启注解扫描 扫描这个路径下的包，就可以在--&gt;    &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;    &lt;!-- 视图解析器对象  视图解析器的类名是固定的，然后配置通过这个视图解析器就可以让controller里面return的东西直接跳转指定的jsp页面        但是还需要配置2个属性，一个是Prefix就是配置找文件的路径        suffix指的是配置的后缀名字。最后也就是找/web-if/pages/下的后缀是jsp的文件--&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;!--前端控制器，哪些静态资源不拦截，location写法就是以后js下所有的请求都不拦截，mapping就是和映射请求有关的,以后jss-图片也需要配置上不拦截--&gt;    &lt;mvc:resources mapping=&quot;/js/&quot; location=&quot;/js/**&quot;/&gt;&lt;!--     开启SpringMVC框架注解的支持 标签是固定的--&gt;    &lt;mvc:annotation-driven  /&gt;&lt;/beans&gt;</code></pre><hr><h2 id="文件上传之传统方式上传代码"><a href="#文件上传之传统方式上传代码" class="headerlink" title="文件上传之传统方式上传代码"></a>文件上传之传统方式上传代码</h2><p>index.jsp文件：<br>    &lt;%–<br>      Created by IntelliJ IDEA.<br>      User: Hun<br>      Date: 2019/11/5<br>      Time: 11:25<br>      To change this template use File | Settings | File Templates.<br>    –%&gt;<br>    &lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;<br>    <html><br>    <head><br>        <title>文件上传</title><br>    </head><br>    <body><br>    <h3>文件上传</h3><br>    <form action="user/fileupload1" method="post" enctype="multipart/form-data"><br>        选择上传文件：<input type="file" name="upload"><br>        <br><br>        <input type="submit" value="上传"><br>    </form><br>    </body><br>    </html></p><hr><p>success.jsp<br>    &lt;%–<br>      Created by IntelliJ IDEA.<br>      User: Hun<br>      Date: 2019/11/5<br>      Time: 11:28<br>      To change this template use File | Settings | File Templates.<br>    –%&gt;<br>    &lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;<br>    <html><br>    <head><br>        <title>Title</title><br>    </head><br>    <body><br>    <h3>上传文件成功</h3><br>    </body><br>    </html></p><hr><pre><code>package cn.itcast.controller;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.List;import java.util.UUID;/** * @Description TODO * @Author TT Hun * @Data 2019/11/5 11:26 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    /**     * 文件上传     * @return     */    @RequestMapping(&quot;/fileupload1&quot;)    public String fileUpload1(HttpServletRequest request) throws Exception{        System.out.println(&quot;文件上传&quot;);//        可以使用fileupload这个组件完成上传//        上传的位置        String path = request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);//        判断改路径是否存在：        File file = new File(path);        if(!file.exists()){            file.mkdirs();        }//    解析request对象获取到上传的文件项        DiskFileItemFactory factory=new DiskFileItemFactory();        ServletFileUpload upload = new ServletFileUpload(factory);//   解析request        List&lt;FileItem&gt; items = upload.parseRequest(request);//        遍历        for(FileItem item:items){//            进行判断，判断item对象是否是上传文件项目            if(item.isFormField()){//                如果是true则是普通表单项目，如果是false则是上传文件项            }else{//                说明是上传文件项//                 获取到上传文件的名称                String filename = item.getName();//                把文件名设置成唯一值，uuid                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);                filename = uuid+&quot;_&quot;+filename;//                完成文件上传                item.write(new File(path,filename));//                删除临时文件。一旦大于10KB就生成临时文件                item.delete();            }        }        return &quot;success&quot;;    }}</code></pre><hr><p>最终结果的图片落在这里：<br><img src="https://i.imgur.com/k0zwX9f.png" alt=""></p><h2 id="SpringMVC上传文件"><a href="#SpringMVC上传文件" class="headerlink" title="SpringMVC上传文件"></a>SpringMVC上传文件</h2><p>首先看一下整体原理：<br>解释一下下面的图：也就是上传的文件通过写在域里面通过request传递到前端控制器，前端控制器通过配置好的文件解析器解析request,然后拿到上传文件。再传递给Controller里面和文件解析器中相同参数名的参数。然后再调用他的方法对他进行使用。<br><img src="https://i.imgur.com/7edLiOL.png" alt=""><br><strong>完整代码如下：</strong><br> Controller</p><pre><code>package cn.itcast.controller;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.List;import java.util.UUID;/** * @Description TODO * @Author TT Hun * @Data 2019/11/5 11:26 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    /**     * 传统方式文件上传     * @return     */    @RequestMapping(&quot;/fileupload1&quot;)    public String fileUpload1(HttpServletRequest request) throws Exception{        System.out.println(&quot;文件上传&quot;);//        可以使用fileupload这个组件完成上传//        上传的位置        String path = request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);//        判断改路径是否存在：        File file = new File(path);        if(!file.exists()){            file.mkdirs();        }//    解析request对象获取到上传的文件项        DiskFileItemFactory factory=new DiskFileItemFactory();        ServletFileUpload upload = new ServletFileUpload(factory);//   解析request        List&lt;FileItem&gt; items = upload.parseRequest(request);//        遍历        for(FileItem item:items){//            进行判断，判断item对象是否是上传文件项目            if(item.isFormField()){//                如果是true则是普通表单项目，如果是false则是上传文件项            }else{//                说明是上传文件项//                 获取到上传文件的名称                String filename = item.getName();//                把文件名设置成唯一值，uuid                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);                filename = uuid+&quot;_&quot;+filename;//                完成文件上传                item.write(new File(path,filename));//                删除临时文件。一旦大于10KB就生成临时文件                item.delete();            }        }        return &quot;success&quot;;    }    /**     * SpringMVC方式文件上传     * @return     */    @RequestMapping(&quot;/fileupload2&quot;)    public String fileUpload2(HttpServletRequest request ,MultipartFile upload) throws Exception{        System.out.println(&quot;文件上传&quot;);//        可以使用fileupload这个组件完成上传//        上传的位置        String path = request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);//        判断改路径是否存在：        File file = new File(path);        if(!file.exists()){            file.mkdirs();        }//         说明是上传文件项//         获取到上传文件的名称        String filename = upload.getOriginalFilename();//         把文件名设置成唯一值，uuid         String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);         filename = uuid+&quot;_&quot;+filename;//         完成文件上传        upload.transferTo(new File(path,filename));        return &quot;success&quot;;    }}</code></pre><hr><p>springmvc.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 开启注解扫描 扫描这个路径下的包，就可以在--&gt;    &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;    &lt;!-- 视图解析器对象  视图解析器的类名是固定的，然后配置通过这个视图解析器就可以让controller里面return的东西直接跳转指定的jsp页面        但是还需要配置2个属性，一个是Prefix就是配置找文件的路径        suffix指的是配置的后缀名字。最后也就是找/web-if/pages/下的后缀是jsp的文件--&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;!--前端控制器，哪些静态资源不拦截，location写法就是以后js下所有的请求都不拦截，mapping就是和映射请求有关的,以后jss-图片也需要配置上不拦截--&gt;    &lt;mvc:resources mapping=&quot;/js/&quot; location=&quot;/js/**&quot;/&gt;&lt;!--    配置文件解析器对象--&gt;    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;!--        这个是配置最大上传文件。value是字节为单位，下面这个也就是10M  --&gt;        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot; /&gt;    &lt;/bean&gt;&lt;!--     开启SpringMVC框架注解的支持 标签是固定的--&gt;    &lt;mvc:annotation-driven  /&gt;&lt;/beans&gt;</code></pre><hr><p>index.jsp</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/5  Time: 11:25  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;文件上传&lt;/h3&gt;&lt;form action=&quot;user/fileupload1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    选择上传文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;    &lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt;&lt;form action=&quot;user/fileupload2&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    选择上传文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;    &lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>web.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--  - This is the Cocoon web-app configurations file  -  - $Id$  --&gt;&lt;web-app version=&quot;2.4&quot;         xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;  &lt;!--配置前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--配置解决中文乱码的过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><hr><p><img src="https://i.imgur.com/I7bTQPD.png" alt=""></p><h2 id="SpringMVC跨服务器方式的文件上传"><a href="#SpringMVC跨服务器方式的文件上传" class="headerlink" title="SpringMVC跨服务器方式的文件上传"></a>SpringMVC跨服务器方式的文件上传</h2><p><img src="https://i.imgur.com/coohqTT.png" alt=""><br>目前跨服务器的内容由于图片服务器没有打开所以目前还没成功，可能是因为图片服务器的配置问题。代码肯定没问题：</p><pre><code>package cn.itcast.controller;import com.sun.jersey.api.client.Client;import com.sun.jersey.api.client.WebResource;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.List;import java.util.UUID;/** * @Description TODO * @Author TT Hun * @Data 2019/11/5 11:26 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    /**     * 跨服务器文件上传     * @return     */    @RequestMapping(&quot;/fileupload3&quot;)    public String fileuoload3(MultipartFile upload) throws Exception {        System.out.println(&quot;跨服务器文件上传...&quot;);        // 定义上传文件服务器路径        String path = &quot;http://localhost:9999/uploads/&quot;;        // 说明上传文件项        // 获取上传文件的名称        String filename = upload.getOriginalFilename();        // 把文件的名称设置唯一值，uuid        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);        filename = uuid+&quot;_&quot;+filename;        // 创建客户端的对象        Client client = Client.create();        // 和图片服务器进行连接        WebResource webResource = client.resource(path + filename);        // 上传文件        webResource.put(upload.getBytes());        return &quot;success&quot;;    }}</code></pre><hr><p>springmvc.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 开启注解扫描 --&gt;    &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;    &lt;!-- 视图解析器对象 --&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!--前端控制器，哪些静态资源不拦截--&gt;    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt;    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;    &lt;!--配置文件解析器对象--&gt;    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 开启SpringMVC框架注解的支持 --&gt;    &lt;mvc:annotation-driven /&gt;&lt;/beans&gt;</code></pre><hr><p>web.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--  Licensed to the Apache Software Foundation (ASF) under one or more  contributor license agreements.  See the NOTICE file distributed with  this work for additional information regarding copyright ownership.  The ASF licenses this file to You under the Apache License, Version 2.0  (the &quot;License&quot;); you may not use this file except in compliance with  the License.  You may obtain a copy of the License at      http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License.--&gt;&lt;!--  - This is the Cocoon web-app configurations file  -  - $Id$  --&gt;&lt;web-app version=&quot;2.4&quot;         xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;  &lt;!--配置前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--配置解决中文乱码的过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><hr><p>index.jsp</p><pre><code>    &lt;%--      Created by IntelliJ IDEA.      User: Hun      Date: 2019/11/5      Time: 11:25      To change this template use File | Settings | File Templates.    --%&gt;    &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;    &lt;html&gt;    &lt;head&gt;        &lt;title&gt;文件上传&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h3&gt;文件上传&lt;/h3&gt;    &lt;form action=&quot;user/fileupload1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        选择上传文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;        &lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;    &lt;/form&gt;    &lt;form action=&quot;user/fileupload2&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        选择上传文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;        &lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;    &lt;/form&gt;    &lt;h2&gt;跨服务器文件上传&lt;/h2&gt;    &lt;form action=&quot;user/fileupload3&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        选择上传文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;        &lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;    &lt;/form&gt;    &lt;/body&gt;    &lt;/html&gt;***success.jsp&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/5  Time: 11:28  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;上传文件成功&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>图片服务器略。</p><h1 id="第三章SpringMVC异常处理"><a href="#第三章SpringMVC异常处理" class="headerlink" title="第三章SpringMVC异常处理"></a>第三章SpringMVC异常处理</h1><h2 id="SpringMVC异常处理之处理代码编写"><a href="#SpringMVC异常处理之处理代码编写" class="headerlink" title="SpringMVC异常处理之处理代码编写"></a>SpringMVC异常处理之处理代码编写</h2><p><img src="https://i.imgur.com/ZHUrpOK.png" alt=""></p><pre><code>package cn.itcast.controller;import cn.itcast.exception.SysException;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @Description TODO * @Author TT Hun * @Data 2019/11/5 22:38 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    @RequestMapping(&quot;/testException&quot;)    public String testException() throws SysException {        System.out.println(&quot;testException 执行了&quot;);        try {//        模拟异常            int a = 10 / 0;        } catch (Exception e) {//            控制台打印异常信息            e.printStackTrace();//           向上抛出异常信息            throw new SysException(&quot;查询所有用户出错了。。。&quot;);        }        return &quot;success&quot;;    }}</code></pre><hr><pre><code>package cn.itcast.exception;/** * @Description 自定义的异常类 * @Author TT Hun * @Data 2019/11/5 23:06 */public class SysException extends Exception {//    用来存储提示信息的    private String message;    @Override    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }    public SysException(String message) {        this.message = message;    }}</code></pre><hr><pre><code>package cn.itcast.exception;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @Description 异常处理器 * @Author TT Hun * @Data 2019/11/5 23:10 */public class SysExceptionResolver implements HandlerExceptionResolver {    /**     * 处理异常逻辑     * @param request     * @param response     * @param handler     * @param ex     * @return     */    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        // 获取到异常对象        SysException e = null;//        判断是否是ex异常        if(ex instanceof SysException) {            e = (SysException) ex;        } else{//如果不是的话            e = new SysException(&quot;系统正在维护....&quot;);        }        // 创建ModelAndView对象，这个modelandview可以帮助跳转到那个界面        ModelAndView mv = new ModelAndView();//        向里面存入提示信息，存了一组键值对        mv.addObject(&quot;errorMsg&quot;,e.getMessage());//        往哪里跳转        mv.setViewName(&quot;error&quot;);        return mv;    }}</code></pre><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 开启注解扫描 --&gt;    &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;    &lt;!-- 视图解析器对象 --&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!--前端控制器，哪些静态资源不拦截--&gt;    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt;    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;    &lt;!--配置异常处理器--&gt;    &lt;bean id=&quot;sysExceptionResolver&quot; class=&quot;cn.itcast.exception.SysExceptionResolver&quot;/&gt;    &lt;!-- 开启SpringMVC框架注解的支持 --&gt;    &lt;mvc:annotation-driven /&gt;&lt;/beans&gt;</code></pre><hr><p>error.jsp</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/6  Time: 9:35  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    ${errorMsg}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>success.jsp</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/5  Time: 22:41  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;测试成功&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><pre><code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--配置解决中文乱码的过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><hr><p>index.jsp</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Administrator  Date: 2018/5/5  Time: 22:08  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;异常处理&lt;/h3&gt;    &lt;a href=&quot;user/testException&quot; &gt;异常处理&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>pom文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--  Licensed to the Apache Software Foundation (ASF) under one  or more contributor license agreements.  See the NOTICE file  distributed with this work for additional information  regarding copyright ownership.  The ASF licenses this file  to you under the Apache License, Version 2.0 (the  &quot;License&quot;); you may not use this file except in compliance  with the License.  You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing,  software distributed under the License is distributed on an  &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  KIND, either express or implied.  See the License for the  specific language governing permissions and limitations  under the License.--&gt;&lt;!-- $Id: pom.xml 642118 2008-03-28 08:04:16Z reinhard $ --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;springmvc_day02_03_exception1&lt;/name&gt;    &lt;artifactId&gt;springmvc_day02_03_exception1&lt;/artifactId&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;                &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;                &lt;version&gt;6.1.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;connectors&gt;                        &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;                            &lt;port&gt;8888&lt;/port&gt;                            &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt;                        &lt;/connector&gt;                    &lt;/connectors&gt;                    &lt;webAppSourceDirectory&gt;${project.build.directory}/${pom.artifactId}-${pom.version}                    &lt;/webAppSourceDirectory&gt;                    &lt;contextPath&gt;/&lt;/contextPath&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><hr><h2 id="SpringMVC中的拦截器"><a href="#SpringMVC中的拦截器" class="headerlink" title="SpringMVC中的拦截器"></a>SpringMVC中的拦截器</h2><p><img src="https://i.imgur.com/AJ9Uzzi.png" alt=""><br>拦截器只会拦截控制器中的方法，也就是Controller中的方法。JSP之类的资源不会拦截的。过滤器什么都可以拦截。也就是拦截器可以做的事情过滤器都可以做。但是过滤器可以做的事情拦截器不一定会做。<br><strong>拦截器完整代码</strong><br>注意Pom中的依赖使用那一些依赖：</p><p>先看一下目录；<br><img src="https://i.imgur.com/q7Ee3uo.png" alt=""></p><pre><code>package cn.itcast.controller.cn.itcast.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 自定义拦截器 */public class MyInterceptor1 implements HandlerInterceptor{    /**     * 预处理，controller方法执行前     * return true 放行，执行下一个拦截器，如果没有，执行controller中的方法     * return false不放行     * @param request     * @param response     * @param handler     * @return     * @throws Exception     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;MyInterceptor1执行了...前1111&quot;);        // request.getRequestDispatcher(&quot;/WEB-INF/pages/error.jsp&quot;).forward(request,response);        return true;    }    /**     * 后处理方法，controller方法执行后，success.jsp执行之前     * @param request     * @param response     * @param handler     * @param modelAndView     * @throws Exception     */    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;MyInterceptor1执行了...后1111&quot;);        // request.getRequestDispatcher(&quot;/WEB-INF/pages/error.jsp&quot;).forward(request,response);    }    /**     * success.jsp页面执行后，该方法会执行     * @param request     * @param response     * @param handler     * @param ex     * @throws Exception     */    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;MyInterceptor1执行了...最后1111&quot;);    }}</code></pre><hr><pre><code>package cn.itcast.controller.cn.itcast.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 自定义拦截器 */public class MyInterceptor2 implements HandlerInterceptor{    /**     * 预处理，controller方法执行前     * return true 放行，执行下一个拦截器，如果没有，执行controller中的方法     * return false不放行     * @param request     * @param response     * @param handler     * @return     * @throws Exception     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;MyInterceptor1执行了...前2222&quot;);        // request.getRequestDispatcher(&quot;/WEB-INF/pages/error.jsp&quot;).forward(request,response);        return true;    }    /**     * 后处理方法，controller方法执行后，success.jsp执行之前     * @param request     * @param response     * @param handler     * @param modelAndView     * @throws Exception     */    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;MyInterceptor1执行了...后2222&quot;);        // request.getRequestDispatcher(&quot;/WEB-INF/pages/error.jsp&quot;).forward(request,response);    }    /**     * success.jsp页面执行后，该方法会执行     * @param request     * @param response     * @param handler     * @param ex     * @throws Exception     */    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;MyInterceptor1执行了...最后2222&quot;);    }}</code></pre><hr><pre><code>package cn.itcast.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/user&quot;)public class UserController {    @RequestMapping(&quot;/testInterceptor&quot;)    public String testInterceptor(){        System.out.println(&quot;testInterceptor执行了...&quot;);        return &quot;success&quot;;    }}</code></pre><hr><p>springmvc.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 开启注解扫描 --&gt;    &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;    &lt;!-- 视图解析器对象 --&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!--前端控制器，哪些静态资源不拦截--&gt;    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt;    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;    &lt;!--配置拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;!--配置拦截器--&gt;        &lt;mvc:interceptor&gt;            &lt;!--要拦截的具体的方法--&gt;            &lt;mvc:mapping path=&quot;/user/*&quot;/&gt;            &lt;!--不要拦截的方法            &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;            --&gt;            &lt;!--配置拦截器对象--&gt;            &lt;bean class=&quot;cn.itcast.controller.cn.itcast.interceptor.MyInterceptor1&quot; /&gt;        &lt;/mvc:interceptor&gt;        &lt;!--配置第二个拦截器--&gt;        &lt;mvc:interceptor&gt;            &lt;!--要拦截的具体的方法--&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;!--不要拦截的方法            &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;            --&gt;            &lt;!--配置拦截器对象--&gt;            &lt;bean class=&quot;cn.itcast.controller.cn.itcast.interceptor.MyInterceptor2&quot; /&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;    &lt;!-- 开启SpringMVC框架注解的支持 --&gt;    &lt;mvc:annotation-driven /&gt;&lt;/beans&gt;</code></pre><hr><p>error.jsp</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/6  Time: 9:35  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    ${errorMsg}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>success.jsp</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/5  Time: 22:41  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;测试成功&lt;/h3&gt;&lt;%--这个代表执行的Java脚本--%&gt;&lt;% System.out.println(&quot;success.jsp成功执行了...  &quot;); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>web.xml</p><pre><code>&lt;!DOCTYPE web-app PUBLIC        &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;        &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--配置解决中文乱码的过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><hr><p>index.jsp</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Administrator  Date: 2018/5/5  Time: 22:08  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;拦截器&lt;/h3&gt;    &lt;a href=&quot;user/testInterceptor&quot; &gt;拦截器&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>pom.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;cn.itcast&lt;/groupId&gt;  &lt;artifactId&gt;springmvc_day02_04_interceptor&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;springmvc_day02_04_interceptor Maven Webapp&lt;/name&gt;  &lt;!-- FIXME change it to the project&apos;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;      &lt;version&gt;2.5&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;      &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;      &lt;version&gt;2.0&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;finalName&gt;springmvc_day02_04_interceptor&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.7.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.20.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章：相应数据和结果视图&quot;&gt;&lt;a href=&quot;#第一章：相应数据和结果视图&quot; class=&quot;headerlink&quot; title=&quot;第一章：相应数据和结果视图&quot;&gt;&lt;/a&gt;第一章：相应数据和结果视图&lt;/h1&gt;&lt;h2 id=&quot;响应之返回值是String类型的&quot;&gt;&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://erichunn.github.io/2019/10/24/SpringMVC/"/>
    <id>http://erichunn.github.io/2019/10/24/SpringMVC/</id>
    <published>2019-10-24T12:57:21.000Z</published>
    <updated>2019-11-03T13:05:35.923Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/UvPSTxH.png" alt=""></p><p>构建SpringMVC工程：</p><p>首先解决工程添加木块过慢的问题，在添加工程的时候，添加如下的属性：</p><p><img src="https://i.imgur.com/LpwgIqJ.png" alt=""></p><p>然后因为开始工程目录不全，要添加一些目录：</p><p><img src="https://i.imgur.com/Kxm31KN.png" alt=""></p><p>需要把HelloController的类交给容器来处理，然后在这个方法上再添加一个注解@ResquestMapping。请求映射注解，也就是一发请求，这个方法就执行了，映射到前台的请求。需要添加一个请求的路径。path=/“hello”。然后服务器一旦启动，点击超链接，让点击超链接跳转到success.jsp界面即可。</p><p><img src="https://i.imgur.com/XsBaIY8.png" alt=""></p><p>下图是springmvc.xml文件配置文件头的讲解：<br><img src="https://i.imgur.com/J7ZJ0jx.png" alt=""></p><p>首先配置里面的开启注解扫描。然后加了这个之后，我们还要让SpringMVC加载这个Springmvc.xml这个配置文件。那么这是怎么加载的那？我们在WEB-INF文件里面的web.xml文件里面也就是前端控制器里面去加载。</p><p>前端控制器代码如下：</p><pre><code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--配置前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--配置解决中文乱码的过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><p>解释一下上面的代码通过org.springframework.web.servlet.DispatcherServlet这个类里面配置classpath:springmvc.xml属性就可以帮我们加载该配置文件</p><hr><p>下面是简单的入门案例的图解：<br><img src="https://i.imgur.com/wLI6qKd.jpg" alt=""></p><hr><p>前端发来请求/hello然后通过前端控制器映射到处理器映射器，然后controller里面的任何方法都会通过处理器适配器，然后在执行相对应的方法。就到了第5步执行，返回的是一个ModelAndView也就是返回的是哪个success.jsp的适配器页面</p><p><img src="https://i.imgur.com/lrTXHqi.png" alt=""></p><p>但是发现为什么只是在springmvc.xml文件中配置了前端控制器呢，因为在配置了springmvc的注解开启之后就默认配置了另外的着一些适配器映射器之类的。<br><img src="https://i.imgur.com/YhOJMgE.png" alt=""></p><hr><p>@RequestMapping用来和前端的请求实现配合。映射过来的。建立映射关联的。可以放到方法上，也可以放到当前类上</p><p>RequestMapping的属性： value和Path属性都是一样的，如果只有一个属性，那么也可以不写这个path和value这个</p><p><img src="https://i.imgur.com/iVu94S8.png" alt=""></p><p>例如：</p><p><img src="https://i.imgur.com/fsbMFI1.png" alt=""></p><hr><hr><hr><p>Springmvc02的视频由于未保存。尚且不理他。等有时间在去更新。</p><hr><hr><hr><p>首先是讲一下RequestParam注解：<br>先来一段例子：</p><p>anno.jsp类：</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 16:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;a href=&quot;anno/testRequestParam?username=haha&quot;&gt;RequestParam&lt;/a&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>paramController类：</p><pre><code>package cn.itcast.controller;import cn.itcast.domain.Account;import cn.itcast.domain.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @Description TODO * @Author TT Hun * @Data 2019/11/2 20:34 */@Controller@RequestMapping(&quot;/param&quot;)public class ParamController {    @RequestMapping(&quot;/hello&quot;)    public String testParam(String username, String password) {        System.out.println(&quot;执行了。。。&quot;);        System.out.println(&quot;用户名:&quot; + username);        System.out.println(&quot;密码:&quot; + password);        return &quot;success&quot;;    }    /**     * 把返回的数据封装到一个javabean的类当中     *     * @return     */    @RequestMapping(&quot;/saveAccount&quot;)    public String saveAccount(Account account) {        System.out.println(&quot;执行了。。。&quot;);        System.out.println(account);        return &quot;success&quot;;    }    @RequestMapping(&quot;/saveUser&quot;)    public String saveUser(User user){        System.out.println(&quot;执行了。。。&quot;);        System.out.println(user);        return &quot;success&quot;;    }}</code></pre><hr><p>一旦上面的username换成了name就不能识别了</p><p><img src="https://i.imgur.com/sScDjjc.png" alt=""><br>所以在Controller类的方法里加上这么一个参数，就可以将name对应的值传递给String username了<br><img src="https://i.imgur.com/3SAMmd9.png" alt=""></p><p>但是以后在jsp中就必须是name=”哈哈”。了，一旦更改成别的就不行了。</p><hr><h2 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="RequestBody注解"></a>RequestBody注解</h2><p><img src="https://i.imgur.com/i1JA9t9.png" alt=""><br>这个就不能写超链接，只能写表单通过post的方式提交</p><pre><code>package cn.itcast.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;/** * @Description 常用的注解 * @Author TT Hun * @Data 2019/11/3 16:59 */@Controller@RequestMapping(&quot;/anno&quot;)public class AnnoController {    @RequestMapping(&quot;/testRequestParam&quot;)    public String  testRequestParam(String username){        System.out.println(&quot;执行了。。。&quot;);        System.out.println(username);        return &quot;success&quot;;    }    @RequestMapping(&quot;/testRequestBody&quot;)    public String  testRequestBody(@RequestBody String body){        System.out.println(&quot;执行了。。。&quot;);        System.out.println(body);        return &quot;success&quot;;    }}</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/2  Time: 20:26  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--自定义类型转换器--%&gt;    &lt;form action=&quot;param/testRequestBody&quot; method=&quot;post&quot;&gt;        用户姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;        用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;br/&gt;        用户生日：&lt;input type=&quot;text&quot; name=&quot;date&quot; /&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;    &lt;/form&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="PathVariable注解"><a href="#PathVariable注解" class="headerlink" title="PathVariable注解"></a>PathVariable注解</h2><p><img src="https://i.imgur.com/Wkn5y2a.png" alt=""></p><p>Restful风格编程：<br>原来在Controller里写很多方法，在path里面写具体的路径，也就是一个方法有一个请求路径，如果是restful风格可以三个方法请求路径都是同一个。可以给不同的方法给固定的请求方式，也就是说可以根据不同的请求方式来执行。那么问题来了，查询一般都是get请求。同一个方法findall和findbyId都有可能 执行怎么办呢，可以通过占位符path=”user/{id}”通过一个id的占位符来区别。</p><p><img src="https://i.imgur.com/oendiQU.png" alt=""></p><p>PathVariable也就是取到的占位符的值。</p><p>代码如下：</p><pre><code>package cn.itcast.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;/** * @Description 常用的注解 * @Author TT Hun * @Data 2019/11/3 16:59 */@Controller@RequestMapping(&quot;/anno&quot;)public class AnnoController {    /**     * PathVariable注解示例     * @return     */    @RequestMapping(&quot;/testPathVariable/{sid}&quot;)    public String  testPathVariable(@PathVariable(name=&quot;sid&quot;)String id ){        System.out.println(&quot;执行了。。。&quot;);        System.out.println(id);        return &quot;success&quot;;    }}</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 16:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;a href=&quot;/anno/testPathVariable/10&quot;&gt;testPathVariable&lt;/a&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="基于HiddenHttpMethodFliter的过滤器"><a href="#基于HiddenHttpMethodFliter的过滤器" class="headerlink" title="基于HiddenHttpMethodFliter的过滤器"></a>基于HiddenHttpMethodFliter的过滤器</h2><p><img src="https://i.imgur.com/oE9J2tq.png" alt=""></p><p>了解一下即可，因为webservie有API可以配置请求方式，并且浏览器中可以装插件来配置请求方式</p><hr><h2 id="RequestHeader注解"><a href="#RequestHeader注解" class="headerlink" title="RequestHeader注解"></a>RequestHeader注解</h2><p><img src="https://i.imgur.com/GMkzdbE.png" alt=""><br>一般用处不大</p><p>package cn.itcast.controller;</p><p>import org.springframework.stereotype.Controller;<br>import org.springframework.web.bind.annotation.*;</p><p>/**</p><ul><li>@Description 常用的注解</li><li>@Author TT Hun</li><li><p>@Data 2019/11/3 16:59<br>*/<br>@Controller<br>@RequestMapping(“/anno”)<br>public class AnnoController {</p><p> /**</p><ul><li>获取请求头信息的值</li><li>@param header</li><li>@return<br>*/<br>@RequestMapping(“/testRequestHeader”)<br>public String  testRequestHeader(@RequestHeader(value=”Accept”) String header){<br> System.out.println(“执行了。。。”);<br> System.out.println(header);<br> return “success”;<br>}<br>}</li></ul></li></ul><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 16:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;a href=&quot;/anno/testRequestHeader&quot;&gt;testRequestHeader&lt;/a&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="Cookie-Value注解"><a href="#Cookie-Value注解" class="headerlink" title="Cookie Value注解"></a>Cookie Value注解</h2><p><img src="https://i.imgur.com/l98bt3M.png" alt=""></p><p>package cn.itcast.controller;</p><p>import org.springframework.stereotype.Controller;<br>import org.springframework.web.bind.annotation.*;</p><p>/**</p><ul><li>@Description 常用的注解</li><li>@Author TT Hun</li><li><p>@Data 2019/11/3 16:59<br>*/<br>@Controller<br>@RequestMapping(“/anno”)<br>public class AnnoController {</p><p> /**</p><ul><li>测试CookieValue注解</li><li>@param cookieValue</li><li>@return<br>*/<br>@RequestMapping(“/testCookieValue”)<br>public String  testCookieValue(@CookieValue(value=”JSESSIONID”) String cookieValue){<br> System.out.println(“执行了。。。”);<br> System.out.println(cookieValue);<br> return “success”;<br>}</li></ul></li></ul><p>}</p><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 16:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;a href=&quot;/anno/testCookieValue&quot;&gt;testCookieValue&lt;/a&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="ModelAttribute注解"></a>ModelAttribute注解</h2><p><img src="https://i.imgur.com/j1zGJPI.png" alt=""></p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 16:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;form action=&quot;anno/testModelAttribute&quot; method=&quot;post&quot;&gt;    用户姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;br&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><pre><code>package cn.itcast.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;/** * @Description 常用的注解 * @Author TT Hun * @Data 2019/11/3 16:59 */@Controller@RequestMapping(&quot;/anno&quot;)public class AnnoController {    /**     * testModelAttribute测试     * @return     */    @RequestMapping(&quot;/testModelAttribute&quot;)    public String  testModelAttribute(){        System.out.println(&quot;testModelAttribute执行了。。。&quot;);        return &quot;success&quot;;    }    @ModelAttribute    public void showUser(){        System.out.println(&quot;showUser方法执行了...&quot;);    }}</code></pre><hr><p>然后打印结果：<br><img src="https://i.imgur.com/UZn18Sr.png" alt=""></p><p>当提交的缺少一个数据，但是想让这个数据从数据库中查询或者缓存中查询。下面是有返回值的情况：</p><pre><code>package cn.itcast.controller;import cn.itcast.domain.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import java.util.Date;/** * @Description 常用的注解 * @Author TT Hun * @Data 2019/11/3 16:59 */@Controller@RequestMapping(&quot;/anno&quot;)public class AnnoController {    /**     * testModelAttribute测试     * @return     */    @RequestMapping(&quot;/testModelAttribute&quot;)    public String  testModelAttribute(User user){        System.out.println(&quot;testModelAttribute执行了。。。&quot;);        System.out.println(user);        return &quot;success&quot;;    }    /**     * 测试ModelAttribute注解的有返回值的情况，     */    @ModelAttribute    public User showUser(String uname ,Integer age){        System.out.println(&quot;showUser方法执行了...&quot;);//        通过用户名查询数据库（模拟）        User user = new User();        user.setUname(uname);        user.setAge(age);        user.setDate(new Date());        return user;    }}</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 16:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;form action=&quot;anno/testModelAttribute&quot; method=&quot;post&quot;&gt;    用户姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;&lt;br/&gt;    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;br&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>打印结果：<br><img src="https://i.imgur.com/Mrcg4Ui.png" alt=""></p><hr><p>下面是没有返回值的写法，可以写入一个Map集合<br>    package cn.itcast.controller;</p><pre><code>import cn.itcast.domain.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import java.util.Date;import java.util.Map;/** * @Description 常用的注解 * @Author TT Hun * @Data 2019/11/3 16:59 */@Controller@RequestMapping(&quot;/anno&quot;)public class AnnoController {</code></pre><p>   /**</p><pre><code> * 测试CookieValue注解 * @param cookieValue * @return */@RequestMapping(&quot;/testCookieValue&quot;)public String  testCookieValue(@CookieValue(value=&quot;JSESSIONID&quot;) String cookieValue){    System.out.println(&quot;执行了。。。&quot;);    System.out.println(cookieValue);    return &quot;success&quot;;}    /**     * 测试没有返回值的ModelAttribute注解     */    @ModelAttribute    public void showUser(String uname , Integer age, Map&lt;String,User&gt; map){        System.out.println(&quot;showUser方法执行了...&quot;);//      通过用户名查询数据库（模拟）        User user = new User();        user.setUname(uname);        user.setAge(age);        user.setDate(new Date());//      查完数据之后存入一个Map集合当中        map.put(&quot;abc&quot;,user);    }}</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 16:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;form action=&quot;anno/testModelAttribute&quot; method=&quot;post&quot;&gt;    用户姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;&lt;br/&gt;    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;br&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="SessionAttribute注解-这个是重点看"><a href="#SessionAttribute注解-这个是重点看" class="headerlink" title="SessionAttribute注解 这个是重点看"></a>SessionAttribute注解 这个是重点看</h2><p><img src="https://i.imgur.com/xt5GfpQ.png" alt=""></p><p>用于在request域里面添加内容，存储到域当中去，并且可以在以后jsp的界面中显示出来。</p><pre><code>package cn.itcast.controller;import cn.itcast.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;import java.util.Date;import java.util.Map;/** * @Description 常用的注解 * @Author TT Hun * @Data 2019/11/3 16:59 */@Controller@RequestMapping(&quot;/anno&quot;)public class AnnoController {    /**     * SessionAttributes的注解     * @return     */    @RequestMapping(&quot;/testSessionAttributes&quot;)    public String testSessionAttributes(Model model){        System.out.println(&quot;testSessionAttributes方法执行了...&quot;);//       向requestSession域里面存值，然后在success.jsp里面取出来,底层会存储到request域对象当中去        model.addAttribute(&quot;msg&quot;,&quot;美美&quot;);        return &quot;success&quot;;    }}</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 16:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;a href=&quot;/anno/testSessionAttributes&quot;&gt;testSessionAttributes&lt;/a&gt;&lt;br&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/10/24  Time: 22:35  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;        &lt;h3&gt;入门成功了&lt;/h3&gt;&lt;%--        表示request域的集合--%&gt;    ${ requestScope }&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>SessionAttributes这个注解智能作用在类上，相当于存到Session这个域当中去，<br>然后使用model.addAttribute相当于把这个信息存储到requestSession这个域当中去。<br>在这个里面添加这个这个</p><p><img src="https://i.imgur.com/31aZ2iR.png" alt=""><br>然后<br><img src="https://i.imgur.com/ft78run.png" alt=""><br>就会显示：<br><img src="https://i.imgur.com/Jr4T50X.png" alt=""></p><hr><p>操作Session的内容进行增加删除查看</p><pre><code>package cn.itcast.controller;import cn.itcast.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.*;import org.springframework.web.bind.support.SessionStatus;import javax.servlet.http.HttpServletRequest;import java.util.Date;import java.util.Map;/** * @Description 常用的注解 * @Author TT Hun * @Data 2019/11/3 16:59 */@Controller@RequestMapping(&quot;/anno&quot;)@SessionAttributes(value={&quot;msg&quot;})//把msg=“美美&quot;在存入到Session域里面一份public class AnnoController {    /**     * 从Session域里面添加值     * @return     */    @RequestMapping(&quot;/testSessionAttributes&quot;)    public String testSessionAttributes(Model model){        System.out.println(&quot;testSessionAttributes方法执行了...&quot;);//       向requestSession域里面存值，然后在success.jsp里面取出来,底层会存储到request域对象当中去        model.addAttribute(&quot;msg&quot;,&quot;美美&quot;);        return &quot;success&quot;;    }    /**     * 从Session域里面取值     * @return     */    @RequestMapping(&quot;/getSessionAttributes&quot;)    public String getSessionAttributes(ModelMap modelMap){        System.out.println(&quot;testSessionAttributes方法执行了...&quot;);//        从Session域里面取值。        String msg = (String)modelMap.get(&quot;msg&quot;);        System.out.println(msg);        return &quot;success&quot;;    }    /**     * 从Session域里面删除值     * @return     */    @RequestMapping(&quot;/deleteSessionAttributes&quot;)    public String deleteSessionAttributes(SessionStatus status){        System.out.println(&quot;testSessionAttributes方法执行了...&quot;);//       把Session里面的东西清除掉。        status.setComplete();        return &quot;success&quot;;    }}</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/11/3  Time: 16:55  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;a href=&quot;/anno/testSessionAttributes&quot;&gt;testSessionAttributes&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/anno/getSessionAttributes&quot;&gt;getSessionAttributes&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/anno/deleteSessionAttributes&quot;&gt;deleteSessionAttributes&lt;/a&gt;&lt;br&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Hun  Date: 2019/10/24  Time: 22:35  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;        &lt;h3&gt;入门成功了&lt;/h3&gt;&lt;%--        表示request域的集合--%&gt;    ${ requestScope.msg }    ${sessionScope}&lt;/body&gt;&lt;/html&gt;</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UvPSTxH.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;构建SpringMVC工程：&lt;/p&gt;
&lt;p&gt;首先解决工程添加木块过慢的问题，在添加工程的时候，添加如下的属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring第四天_基于纯注解事务控制+回顾部分注解例子</title>
    <link href="http://erichunn.github.io/2019/10/24/Spring%E7%AC%AC%E5%9B%9B%E5%A4%A9-%E5%9F%BA%E4%BA%8E%E7%BA%AF%E6%B3%A8%E8%A7%A3%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6-%E5%9B%9E%E9%A1%BE%E9%83%A8%E5%88%86%E6%B3%A8%E8%A7%A3%E4%BE%8B%E5%AD%90/"/>
    <id>http://erichunn.github.io/2019/10/24/Spring第四天-基于纯注解事务控制-回顾部分注解例子/</id>
    <published>2019-10-24T12:34:48.000Z</published>
    <updated>2019-10-24T12:39:17.610Z</updated>
    
    <content type="html"><![CDATA[<pre><code>package com.itheima.dao;import com.itheima.domain.Account;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 根据Id查询账户     * @param accountId     * @return     */    Account findAccountById(Integer accountId);    /**     * 根据名称查询账户     * @param accountName     * @return     */    Account findAccountByName(String accountName);    /**     * 更新账户     * @param account     */    void updateAccount(Account account);}</code></pre><hr><pre><code>package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;/** * 账户的持久层实现类 */@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao {    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public Account findAccountById(Integer accountId) {        List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account where id = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);        return accounts.isEmpty()?null:accounts.get(0);    }    @Override    public Account findAccountByName(String accountName) {        List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account where name = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);        if(accounts.isEmpty()){            return null;        }        if(accounts.size()&gt;1){            throw new RuntimeException(&quot;结果集不唯一&quot;);        }        return accounts.get(0);    }    @Override    public void updateAccount(Account account) {        jdbcTemplate.update(&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId());    }}</code></pre><hr><pre><code>package com.itheima.domain;import java.io.Serializable;/** * 账户的实体类 */public class Account implements Serializable {    private Integer id;    private String name;    private Float money;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Float getMoney() {        return money;    }    public void setMoney(Float money) {        this.money = money;    }    @Override    public String toString() {        return &quot;Account{&quot; +                &quot;id=&quot; + id +                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +                &quot;, money=&quot; + money +                &apos;}&apos;;    }}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 根据id查询账户信息     * @param accountId     * @return     */    Account findAccountById(Integer accountId);    /**     * 转账     * @param sourceName    转成账户名称     * @param targetName    转入账户名称     * @param money         转账金额     */    void transfer(String sourceName, String targetName, Float money);}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;/** * 账户的业务层实现类 * * 事务控制应该都是在业务层 */@Service(&quot;accountService&quot;)@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)//只读型事务的配置public class AccountServiceImpl implements IAccountService{    @Autowired    private IAccountDao accountDao;    @Override    public Account findAccountById(Integer accountId) {        return accountDao.findAccountById(accountId);    }    //需要的是读写型事务配置    @Transactional(propagation= Propagation.REQUIRED,readOnly=false)    @Override    public void transfer(String sourceName, String targetName, Float money) {        System.out.println(&quot;transfer....&quot;);            //2.1根据名称查询转出账户            Account source = accountDao.findAccountByName(sourceName);            //2.2根据名称查询转入账户            Account target = accountDao.findAccountByName(targetName);            //2.3转出账户减钱            source.setMoney(source.getMoney()-money);            //2.4转入账户加钱            target.setMoney(target.getMoney()+money);            //2.5更新转出账户            accountDao.updateAccount(source);//            int i=1/0;            //2.6更新转入账户            accountDao.updateAccount(target);    }}</code></pre><hr><p>重点看下面Config文件夹下面几个类：</p><pre><code>package config;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;/** * 和连接数据库相关的配置类 */public class JdbcConfig {    @Value(&quot;${jdbc.driver}&quot;)    private String driver;    @Value(&quot;${jdbc.url}&quot;)    private String url;    @Value(&quot;${jdbc.username}&quot;)    private String username;    @Value(&quot;${jdbc.password}&quot;)    private String password;    /**     * 创建JdbcTemplate     * @param dataSource     * @return     */    @Bean(name=&quot;jdbcTemplate&quot;)    public JdbcTemplate createJdbcTemplate(DataSource dataSource){        return new JdbcTemplate(dataSource);    }    /**     * 创建数据源对象     * @return     */    @Bean(name=&quot;dataSource&quot;)    public DataSource createDataSource(){        DriverManagerDataSource ds = new DriverManagerDataSource();        ds.setDriverClassName(driver);        ds.setUrl(url);        ds.setUsername(username);        ds.setPassword(password);        return ds;    }}</code></pre><hr><pre><code>package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.PropertySource;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * spring的配置类，相当于bean.xml */@Configuration@ComponentScan(&quot;com.itheima&quot;)@Import({JdbcConfig.class,TransactionConfig.class})@PropertySource(&quot;jdbcConfig.properties&quot;)@EnableTransactionManagementpublic class SpringConfiguration {}</code></pre><hr><pre><code>package config;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import javax.sql.DataSource;/** * 和事务相关的配置类 */public class TransactionConfig {    /**     * 用于创建事务管理器对象     * @param dataSource     * @return     */    @Bean(name=&quot;transactionManager&quot;)    public PlatformTransactionManager createTransactionManager(DataSource dataSource){        return new DataSourceTransactionManager(dataSource);    }}</code></pre><hr><p>resource包下properties文件：</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesyjdbc.username=rootjdbc.password=1234</code></pre><hr><pre><code>package com.itheima.test;import com.itheima.service.IAccountService;import config.SpringConfiguration;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes= SpringConfiguration.class)public class AccountServiceTest {    @Autowired    private  IAccountService as;    @Test    public  void testTransfer(){        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;package com.itheima.dao;

import com.itheima.domain.Account;

/**
 * 账户的持久层接口
 */
public interface IAccountDao {

    /**
     * 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring第四天_关于事务的控制通过XML和纯注解</title>
    <link href="http://erichunn.github.io/2019/10/23/Spring%E7%AC%AC%E5%9B%9B%E5%A4%A9-%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E9%80%9A%E8%BF%87XML%E5%92%8C%E7%BA%AF%E6%B3%A8%E8%A7%A3/"/>
    <id>http://erichunn.github.io/2019/10/23/Spring第四天-关于事务的控制通过XML和纯注解/</id>
    <published>2019-10-23T08:01:28.000Z</published>
    <updated>2019-10-23T14:01:28.934Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Spring控制的一组关于事务的"><a href="#Spring控制的一组关于事务的" class="headerlink" title="Spring控制的一组关于事务的"></a><strong>Spring控制的一组关于事务的</strong></h2><p><img src="https://i.imgur.com/wbPn7UK.png" alt=""></p><p><img src="https://i.imgur.com/tuVVVR8.png" alt=""></p><p><img src="https://i.imgur.com/r7PWC1h.png" alt=""></p><p><img src="https://i.imgur.com/2pWccm5.png" alt=""></p><p><img src="https://i.imgur.com/LatSmwW.png" alt=""></p><p><img src="https://i.imgur.com/QgRHylQ.png" alt=""><br><img src="https://i.imgur.com/LzhM2Vn.png" alt=""></p><h2 id="Spring基于XML的声明式事务控制（）"><a href="#Spring基于XML的声明式事务控制（）" class="headerlink" title="Spring基于XML的声明式事务控制（）"></a>Spring基于XML的声明式事务控制（）</h2><p>前面的处理还是按照以前银行例子的配置，这个地方重点看bean配置文件的配置。</p><pre><code>package com.itheima.dao;import com.itheima.domain.Account;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 根据Id查询账户     * @param accountId     * @return     */    Account findAccountById(Integer accountId);    /**     * 根据名称查询账户     * @param accountName     * @return     */    Account findAccountByName(String accountName);    /**     * 更新账户     * @param account     */    void updateAccount(Account account);}</code></pre><hr><pre><code>package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.support.JdbcDaoSupport;import java.util.List;/** * 账户的持久层实现类 */public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao {    @Override    public Account findAccountById(Integer accountId) {        List&lt;Account&gt; accounts = super.getJdbcTemplate().query(&quot;select * from account where id = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);        return accounts.isEmpty()?null:accounts.get(0);    }    @Override    public Account findAccountByName(String accountName) {        List&lt;Account&gt; accounts = super.getJdbcTemplate().query(&quot;select * from account where name = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);        if(accounts.isEmpty()){            return null;        }        if(accounts.size()&gt;1){            throw new RuntimeException(&quot;结果集不唯一&quot;);        }        return accounts.get(0);    }    @Override    public void updateAccount(Account account) {        super.getJdbcTemplate().update(&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId());    }}</code></pre><hr><pre><code>package com.itheima.domain;import java.io.Serializable;/** * 账户的实体类 */public class Account implements Serializable {    private Integer id;    private String name;    private Float money;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Float getMoney() {        return money;    }    public void setMoney(Float money) {        this.money = money;    }    @Override    public String toString() {        return &quot;Account{&quot; +                &quot;id=&quot; + id +                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +                &quot;, money=&quot; + money +                &apos;}&apos;;    }}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 根据id查询账户信息     * @param accountId     * @return     */    Account findAccountById(Integer accountId);    /**     * 转账     * @param sourceName    转成账户名称     * @param targetName    转入账户名称     * @param money         转账金额     */    void transfer(String sourceName, String targetName, Float money);}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;/** * 账户的业务层实现类 * * 事务控制应该都是在业务层 */public class AccountServiceImpl implements IAccountService{    private IAccountDao accountDao;    public void setAccountDao(IAccountDao accountDao) {        this.accountDao = accountDao;    }    @Override    public Account findAccountById(Integer accountId) {        return accountDao.findAccountById(accountId);    }    @Override    public void transfer(String sourceName, String targetName, Float money) {        System.out.println(&quot;transfer....&quot;);            //2.1根据名称查询转出账户            Account source = accountDao.findAccountByName(sourceName);            //2.2根据名称查询转入账户            Account target = accountDao.findAccountByName(targetName);            //2.3转出账户减钱            source.setMoney(source.getMoney()-money);            //2.4转入账户加钱            target.setMoney(target.getMoney()+money);            //2.5更新转出账户            accountDao.updateAccount(source);            int i=1/0;            //2.6更新转入账户            accountDao.updateAccount(target);    }}</code></pre><hr><h3 id="下面重点看："><a href="#下面重点看：" class="headerlink" title="下面重点看："></a>下面重点看：</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 配置业务层--&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置账户的持久层--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- spring中基于XML的声明式事务控制配置步骤        1、配置事务管理器        2、配置事务的通知                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的                使用tx:advice标签配置事务通知                    属性：                        id：给事务通知起一个唯一标识                        transaction-manager：给事务通知提供一个事务管理器引用        3、配置AOP中的通用切入点表达式        4、建立事务通知和切入点表达式的对应关系        5、配置事务的属性               是在事务的通知tx:advice标签的内部     --&gt;    &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置事务的通知--&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;!-- 配置事务的属性                isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。                propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。                read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。                timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。                rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。                no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。        --&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- 配置aop--&gt;    &lt;aop:config&gt;        &lt;!-- 配置切入点表达式--&gt;        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;        &lt;!--建立切入点表达式和事务通知的对应关系 --&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><hr><pre><code>package com.itheima.test;import com.itheima.service.IAccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)public class AccountServiceTest {    @Autowired    private  IAccountService as;    @Test    public  void testTransfer(){        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);    }}</code></pre><hr><p>这个地方重点看的配置就是bean里面的配置：</p><hr><p>两种DAO的编写方式：（回顾一下DAO的实现方式）<br><img src="https://i.imgur.com/MZUtq3f.png" alt=""></p><p><img src="https://i.imgur.com/aFDLkTS.png" alt=""></p><hr><pre><code>package com.itheima.dao;import com.itheima.domain.Account;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 根据Id查询账户     * @param accountId     * @return     */    Account findAccountById(Integer accountId);    /**     * 根据名称查询账户     * @param accountName     * @return     */    Account findAccountByName(String accountName);    /**     * 更新账户     * @param account     */    void updateAccount(Account account);}</code></pre><hr><pre><code>package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;/** * 账户的持久层实现类 */@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao {    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public Account findAccountById(Integer accountId) {        List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account where id = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);        return accounts.isEmpty()?null:accounts.get(0);    }    @Override    public Account findAccountByName(String accountName) {        List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account where name = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);        if(accounts.isEmpty()){            return null;        }        if(accounts.size()&gt;1){            throw new RuntimeException(&quot;结果集不唯一&quot;);        }        return accounts.get(0);    }    @Override    public void updateAccount(Account account) {        jdbcTemplate.update(&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId());    }}</code></pre><hr><pre><code>package com.itheima.domain;import java.io.Serializable;/** * 账户的实体类 */public class Account implements Serializable {    private Integer id;    private String name;    private Float money;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Float getMoney() {        return money;    }    public void setMoney(Float money) {        this.money = money;    }    @Override    public String toString() {        return &quot;Account{&quot; +                &quot;id=&quot; + id +                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +                &quot;, money=&quot; + money +                &apos;}&apos;;    }}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 根据id查询账户信息     * @param accountId     * @return     */    Account findAccountById(Integer accountId);    /**     * 转账     * @param sourceName    转成账户名称     * @param targetName    转入账户名称     * @param money         转账金额     */    void transfer(String sourceName, String targetName, Float money);}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;/** * 账户的业务层实现类 * * 事务控制应该都是在业务层 */@Service(&quot;accountService&quot;)@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)//只读型事务的配置public class AccountServiceImpl implements IAccountService{    @Autowired    private IAccountDao accountDao;    @Override    public Account findAccountById(Integer accountId) {        return accountDao.findAccountById(accountId);    }    //需要的是读写型事务配置    @Transactional(propagation= Propagation.REQUIRED,readOnly=false)    @Override    public void transfer(String sourceName, String targetName, Float money) {        System.out.println(&quot;transfer....&quot;);            //2.1根据名称查询转出账户            Account source = accountDao.findAccountByName(sourceName);            //2.2根据名称查询转入账户            Account target = accountDao.findAccountByName(targetName);            //2.3转出账户减钱            source.setMoney(source.getMoney()-money);            //2.4转入账户加钱            target.setMoney(target.getMoney()+money);            //2.5更新转出账户            accountDao.updateAccount(source);            int i=1/0;            //2.6更新转入账户            accountDao.updateAccount(target);    }}</code></pre><hr><p>重点的bean配置文件：</p><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 配置spring创建容器时要扫描的包--&gt;    &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 配置JdbcTemplate--&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- spring中基于注解 的声明式事务控制配置步骤        1、配置事务管理器        2、开启spring对注解事务的支持        3、在需要事务支持的地方使用@Transactional注解     --&gt;    &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 开启spring对注解事务的支持--&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt;</code></pre><hr><pre><code>package com.itheima.test;import com.itheima.service.IAccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)public class AccountServiceTest {    @Autowired    private  IAccountService as;    @Test    public  void testTransfer(){        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);    }}</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;Spring控制的一组关于事务的&quot;&gt;&lt;a href=&quot;#Spring控制的一组关于事务的&quot; class=&quot;headerlink&quot; title=&quot;Spring控制的一组关于事务的&quot;&gt;&lt;/a&gt;&lt;strong&gt;Spring控制的一组关于事务的&lt;/strong&gt;
      
    
    </summary>
    
      <category term="Spring" scheme="http://erichunn.github.io/categories/Spring/"/>
    
    
      <category term="事务控制" scheme="http://erichunn.github.io/tags/%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
    
      <category term="XML控制事务" scheme="http://erichunn.github.io/tags/XML%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="纯注解控制事务" scheme="http://erichunn.github.io/tags/%E7%BA%AF%E6%B3%A8%E8%A7%A3%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring第四天_Spring中事务控制-作业例子</title>
    <link href="http://erichunn.github.io/2019/10/08/Spring%E7%AC%AC%E5%9B%9B%E5%A4%A9_Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6-%E4%BD%9C%E4%B8%9A%E4%BE%8B%E5%AD%90/"/>
    <id>http://erichunn.github.io/2019/10/08/Spring第四天_Spring中事务控制-作业例子/</id>
    <published>2019-10-08T14:53:37.000Z</published>
    <updated>2019-10-23T08:02:44.871Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>这节主要讲解了从银行转账的一个基于XML配置文件的，一个是基于注解配置的两个案例。2个都是比较完整的代码，没有测试过，可能因为数据库8.0问题导致连接不上，但是代码应该没有问题。可以作为例子深入研究一下注解和XML文件配置。</strong></p></blockquote><p>首先，由注解开发的银行转账案例完整版作业：</p><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import java.util.List;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);    /**     * 根据名称查账户     * @param accountName   用户名称     * @return      如果有唯一结果就返回，如果没有结果就返回Null,结果集超过一个返回异常     */    Account findAccountByName(String accountName);}</code></pre><hr><pre><code>package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.util.List;/** * 账户的持久层实现类 */public class AccountDaoImpl implements IAccountDao {    private QueryRunner runner;    private ConnectionUtils connectionUtils;    public void setRunner(QueryRunner runner) {        this.runner = runner;    }    public void setConnectionUtils(ConnectionUtils connectionUtils) {        this.connectionUtils = connectionUtils;    }    public List&lt;Account&gt; findAllAccount() {        try{            return runner.query(connectionUtils.getThreadConnection(),&quot;select * from account&quot;,new BeanListHandler&lt;Account&gt;(Account.class));        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountById(Integer accountId) {        try{            return runner.query(connectionUtils.getThreadConnection(),&quot;select * from account where id = ? &quot;,new BeanHandler&lt;Account&gt;(Account.class),accountId);        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public void saveAccount(Account account) {        try{            runner.update(connectionUtils.getThreadConnection(),&quot;insert into account(name,money)values(?,?)&quot;,account.getName(),account.getMoney());        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public void updateAccount(Account account) {        try{            runner.update(connectionUtils.getThreadConnection(),&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId());        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public void deleteAccount(Integer accountId) {        try{            runner.update(connectionUtils.getThreadConnection(),&quot;delete from account where id=?&quot;,accountId);        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountByName(String accountName) {        try{            List&lt;Account&gt; accounts = runner.query(connectionUtils.getThreadConnection(),&quot;select * from account where name = ? &quot;,new BeanListHandler&lt;Account&gt;(Account.class),accountName);            if(accounts == null || accounts.size() == 0){                return null;            }            if(accounts.size() &gt; 1){                throw new RuntimeException(&quot;结果集不唯一，数据有问题&quot;);            }            return accounts.get(0);        }catch (Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><hr><pre><code>package com.itheima.domain;import java.io.Serializable;/** * 账户的实体类 */public class Account implements Serializable {    private Integer id;    private String name;    private Float money;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Float getMoney() {        return money;    }    public void setMoney(Float money) {        this.money = money;    }    @Override    public String toString() {        return &quot;Account{&quot; +                &quot;id=&quot; + id +                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +                &quot;, money=&quot; + money +                &apos;}&apos;;    }}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);    /**     *     * 转账方法     * @param sourceName    转出账户名称     * @param targetName    转入账户名称     * @param money         转账金额     */    void transfer(String sourceName, String targetName, Float money);}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import com.itheima.utils.TransactionManager;import java.util.List;/** * 账户的业务层实现类 * * 事务控制应该都是在业务层 */public class AccountServiceImpl implements IAccountService{    private IAccountDao accountDao;    private TransactionManager txManager;    public void setTxManager(TransactionManager txManager) {        this.txManager = txManager;    }    public void setAccountDao(IAccountDao accountDao) {        this.accountDao = accountDao;    }    @Override    public List&lt;Account&gt; findAllAccount() {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            List&lt;Account&gt; accounts = accountDao.findAllAccount();            //3.提交事务            txManager.commit();            //4.返回结果            return accounts;        }catch (Exception e){            //5.回滚操作            txManager.rollback();            throw new RuntimeException(e);        }finally {            //6.释放连接            txManager.release();        }    }    @Override    public Account findAccountById(Integer accountId) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            Account account = accountDao.findAccountById(accountId);            //3.提交事务            txManager.commit();            //4.返回结果            return account;        }catch (Exception e){            //5.回滚操作            txManager.rollback();            throw new RuntimeException(e);        }finally {            //6.释放连接            txManager.release();        }    }    @Override    public void saveAccount(Account account) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            accountDao.saveAccount(account);            //3.提交事务            txManager.commit();        }catch (Exception e){            //4.回滚操作            txManager.rollback();        }finally {            //5.释放连接            txManager.release();        }    }    @Override    public void updateAccount(Account account) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            accountDao.updateAccount(account);            //3.提交事务            txManager.commit();        }catch (Exception e){            //4.回滚操作            txManager.rollback();        }finally {            //5.释放连接            txManager.release();        }    }    @Override    public void deleteAccount(Integer acccountId) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            accountDao.deleteAccount(acccountId);            //3.提交事务            txManager.commit();        }catch (Exception e){            //4.回滚操作            txManager.rollback();        }finally {            //5.释放连接            txManager.release();        }    }    @Override    public void transfer(String sourceName, String targetName, Float money) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            //2.1根据名称查询转出账户            Account source = accountDao.findAccountByName(sourceName);            //2.2根据名称查询转入账户            Account target = accountDao.findAccountByName(targetName);            //2.3转出账户减钱            source.setMoney(source.getMoney()-money);            //2.4转入账户加钱            target.setMoney(target.getMoney()+money);            //2.5更新转出账户            accountDao.updateAccount(source);            int i=1/0;            //2.6更新转入账户            accountDao.updateAccount(target);            //3.提交事务            txManager.commit();        }catch (Exception e){            //4.回滚操作            txManager.rollback();            e.printStackTrace();        }finally {            //5.释放连接            txManager.release();        }    }}</code></pre><hr><pre><code>package com.itheima.utils;import javax.sql.DataSource;import java.sql.Connection;/** * @Description 连接的工具类，用于从数据源中获取一个连接，并且实现和线程的绑定 * @Author TT Hun * @Data 2019/10/3 11:22 */public class ConnectionUtils {    private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();    private DataSource dataSource;    public void setDataSource(DataSource dataSource) {        this.dataSource = dataSource;    }    /**     * 获取当前线程上的链接     *     * @return     */    public Connection getThreadConnection() {//        1、先从ThreadLocal上获取        Connection conn = tl.get();//        2、判断当前线程上是否有链接        try {            if (conn == null) {//        3、从数据源中获取一个连接，并且存入ThreadLocalz中                conn = dataSource.getConnection();                tl.set(conn);            }//        4、返回当前线程上的连接            return conn;        } catch (Exception e) {            throw new RuntimeException(&quot;报错了&quot;);        }    }    /**     * 链接和线程解绑     */    public void removeConnection(){        tl.remove();    }}</code></pre><hr><pre><code>package com.itheima.utils;/** * @Description 和事务管理相关的工具类，包含了开启事务，提交事务，回滚事务和释放连接的方法 * @Author TT Hun * @Data 2019/10/3 11:35 */public class TransactionManager {    private ConnectionUtils connectionUtils;    public void setConnectionUtils(ConnectionUtils connectionUtils) {        this.connectionUtils = connectionUtils;    }    /**     * 开始事务     */    public void beginTransaction() {        try {            connectionUtils.getThreadConnection().setAutoCommit(false);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 提交事务     */    public void commit() {        try {            connectionUtils.getThreadConnection().commit();        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 回滚事务     */    public void rollback() {        try {            connectionUtils.getThreadConnection().rollback();        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 释放连接事务     */    public void release() {        try {//            使用服务器也有一个线程池，当tomcat启动时候，会初始化一大堆线程放到一个容器中//            每次访问都是线程池中拿出来一个线程给我们使用，调用close方法并不是真正的关闭而是将线程还给线程池            connectionUtils.getThreadConnection().close();//            所以想要连接和线程解绑，通过这个方法。            connectionUtils.removeConnection();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 配置Service --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;        &lt;!-- 注入dao --&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置Dao对象--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;        &lt;!-- 注入QueryRunner --&gt;        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;&lt;!--        注入ConnectionUtils--&gt;        &lt;property name=&quot;connectionUtils&quot; ref =&quot;connectionUtils&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置QueryRunner--&gt;    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;    &lt;/bean&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!--连接数据库的必备信息--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy?characterEncoding=utf8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=false&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--    配置Connection的工具类 ConnectionUtils--&gt;    &lt;bean id =&quot;connectionUtils&quot; class =&quot;com.itheima.utils.ConnectionUtils&quot;&gt;&lt;!--        注入数据源--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--    配置事务管理器--&gt;    &lt;bean id=&quot;txManager&quot; class=&quot;com.itheima.utils.TransactionManager&quot;&gt;&lt;!--        注入ConnectionUtils--&gt;        &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--    配置AOP--&gt;    &lt;aop:config&gt;&lt;!--        配置通用的切入点表达式--&gt;        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..)))&quot;&gt;&lt;/aop:pointcut&gt;        &lt;aop:aspect id=&quot;txAdvice&quot; ref=&quot;txManager&quot;&gt;&lt;!--            配置前置通知，开启事务--&gt;        &lt;aop:before method=&quot;beginTransaction&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;&lt;!--            配置后置通知，提交事务--&gt;            &lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt;&lt;!--            配置异常通知，回滚事务--&gt;            &lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt;&lt;!--            配置最终通知，释放连接--&gt;            &lt;aop:after method=&quot;release&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><hr><pre><code>package com.itheima.test;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)public class AccountServiceTest {    @Autowired    private  IAccountService as;    @Test    public void testTransfer(){        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);    }}</code></pre><hr><hr><hr><p>下面是基于注解的银行转行范例：</p><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import java.util.List;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);    /**     * 根据名称查账户     * @param accountName   用户名称     * @return      如果有唯一结果就返回，如果没有结果就返回Null,结果集超过一个返回异常     */    Account findAccountByName(String accountName);}</code></pre><hr><pre><code>package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import java.util.List;/** * 账户的持久层实现类 */@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao {    @Autowired    private QueryRunner runner;    @Autowired    private ConnectionUtils connectionUtils;    public List&lt;Account&gt; findAllAccount() {        try{            return runner.query(connectionUtils.getThreadConnection(),&quot;select * from account&quot;,new BeanListHandler&lt;Account&gt;(Account.class));        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountById(Integer accountId) {        try{            return runner.query(connectionUtils.getThreadConnection(),&quot;select * from account where id = ? &quot;,new BeanHandler&lt;Account&gt;(Account.class),accountId);        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public void saveAccount(Account account) {        try{            runner.update(connectionUtils.getThreadConnection(),&quot;insert into account(name,money)values(?,?)&quot;,account.getName(),account.getMoney());        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public void updateAccount(Account account) {        try{            runner.update(connectionUtils.getThreadConnection(),&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId());        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public void deleteAccount(Integer accountId) {        try{            runner.update(connectionUtils.getThreadConnection(),&quot;delete from account where id=?&quot;,accountId);        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountByName(String accountName) {        try{            List&lt;Account&gt; accounts = runner.query(connectionUtils.getThreadConnection(),&quot;select * from account where name = ? &quot;,new BeanListHandler&lt;Account&gt;(Account.class),accountName);            if(accounts == null || accounts.size() == 0){                return null;            }            if(accounts.size() &gt; 1){                throw new RuntimeException(&quot;结果集不唯一，数据有问题&quot;);            }            return accounts.get(0);        }catch (Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><hr><pre><code>package com.itheima.domain;import java.io.Serializable;/** * 账户的实体类 */public class Account implements Serializable {    private Integer id;    private String name;    private Float money;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Float getMoney() {        return money;    }    public void setMoney(Float money) {        this.money = money;    }    @Override    public String toString() {        return &quot;Account{&quot; +                &quot;id=&quot; + id +                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +                &quot;, money=&quot; + money +                &apos;}&apos;;    }}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);    /**     *     * 转账方法     * @param sourceName    转出账户名称     * @param targetName    转入账户名称     * @param money         转账金额     */    void transfer(String sourceName, String targetName, Float money);}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import com.itheima.utils.TransactionManager;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 账户的业务层实现类 * * 事务控制应该都是在业务层 */@Service(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService{    @Autowired//dao自动按照类型注入    private IAccountDao accountDao;    @Autowired    private TransactionManager txManager;    public List&lt;Account&gt; findAllAccount() {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            List&lt;Account&gt; accounts = accountDao.findAllAccount();            //3.提交事务            txManager.commit();            //4.返回结果            return accounts;        }catch (Exception e){            //5.回滚操作            txManager.rollback();            throw new RuntimeException(e);        }finally {            //6.释放连接            txManager.release();        }    }    @Override    public Account findAccountById(Integer accountId) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            Account account = accountDao.findAccountById(accountId);            //3.提交事务            txManager.commit();            //4.返回结果            return account;        }catch (Exception e){            //5.回滚操作            txManager.rollback();            throw new RuntimeException(e);        }finally {            //6.释放连接            txManager.release();        }    }    @Override    public void saveAccount(Account account) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            accountDao.saveAccount(account);            //3.提交事务            txManager.commit();        }catch (Exception e){            //4.回滚操作            txManager.rollback();        }finally {            //5.释放连接            txManager.release();        }    }    @Override    public void updateAccount(Account account) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            accountDao.updateAccount(account);            //3.提交事务            txManager.commit();        }catch (Exception e){            //4.回滚操作            txManager.rollback();        }finally {            //5.释放连接            txManager.release();        }    }    @Override    public void deleteAccount(Integer acccountId) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            accountDao.deleteAccount(acccountId);            //3.提交事务            txManager.commit();        }catch (Exception e){            //4.回滚操作            txManager.rollback();        }finally {            //5.释放连接            txManager.release();        }    }    @Override    public void transfer(String sourceName, String targetName, Float money) {        try {            //1.开启事务            txManager.beginTransaction();            //2.执行操作            //2.1根据名称查询转出账户            Account source = accountDao.findAccountByName(sourceName);            //2.2根据名称查询转入账户            Account target = accountDao.findAccountByName(targetName);            //2.3转出账户减钱            source.setMoney(source.getMoney()-money);            //2.4转入账户加钱            target.setMoney(target.getMoney()+money);            //2.5更新转出账户            accountDao.updateAccount(source);//            int i=1/0;            //2.6更新转入账户            accountDao.updateAccount(target);            //3.提交事务            txManager.commit();        }catch (Exception e){            //4.回滚操作            txManager.rollback();            e.printStackTrace();        }finally {            //5.释放连接            txManager.release();        }    }}</code></pre><hr><pre><code>package com.itheima.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.sql.DataSource;import java.sql.Connection;/** * @Description 连接的工具类，用于从数据源中获取一个连接，并且实现和线程的绑定 * @Author TT Hun * @Data 2019/10/3 11:22 */@Component(&quot;connectionUtils&quot;)public class ConnectionUtils {    private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();    @Autowired    private DataSource dataSource;    public void setDataSource(DataSource dataSource) {        this.dataSource = dataSource;    }    /**     * 获取当前线程上的链接     *     * @return     */    public Connection getThreadConnection() {//        1、先从ThreadLocal上获取        Connection conn = tl.get();//        2、判断当前线程上是否有链接        try {            if (conn == null) {//        3、从数据源中获取一个连接，并且存入ThreadLocalz中                conn = dataSource.getConnection();                tl.set(conn);            }//        4、返回当前线程上的连接            return conn;        } catch (Exception e) {            throw new RuntimeException(&quot;报错了&quot;);        }    }    /**     * 链接和线程解绑     */    public void removeConnection() {        tl.remove();    }}</code></pre><hr><pre><code>package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.junit.AfterClass;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.management.relation.RoleUnresolved;/** * @Description 和事务管理相关的工具类，包含了开启事务，提交事务，回滚事务和释放连接的方法 * @Author TT Hun * @Data 2019/10/3 11:35 */@Component(&quot;txManager&quot;)@Aspect//配置切面，表示当前类是一个切面类public class TransactionManager {    @Autowired    private ConnectionUtils connectionUtils;    @Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)//切入点表达式    private void pt1(){}    /**     * 开始事务     *///    @Before(&quot;pt1()&quot;)不写这个因为配置注解开发会导致首先出发before然后出发release最后出发commit    public void beginTransaction() {        try {            connectionUtils.getThreadConnection().setAutoCommit(false);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 提交事务     *///    @AfterReturning(&quot;pt1()&quot;)不写这个因为配置注解开发会导致首先出发before然后出发release最后出发commit    public void commit() {        try {            connectionUtils.getThreadConnection().commit();        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 回滚事务     *///    @AfterReturning(&quot;pt1()&quot;)不写这个因为配置注解开发会导致首先出发before然后出发release最后出发commit    public void rollback() {        try {            connectionUtils.getThreadConnection().rollback();        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 释放连接事务     *///    @After(&quot;pt1()&quot;)不写这个因为配置注解开发会导致首先出发before然后出发release最后出发commit    public void release() {        try {//            使用服务器也有一个线程池，当tomcat启动时候，会初始化一大堆线程放到一个容器中//            每次访问都是线程池中拿出来一个线程给我们使用，调用close方法并不是真正的关闭而是将线程还给线程池            connectionUtils.getThreadConnection().close();//            所以想要连接和线程解绑，通过这个方法。            connectionUtils.removeConnection();        } catch (Exception e) {            e.printStackTrace();        }    }    @Around(&quot;pt1()&quot;)    public Object aroundAdvice(ProceedingJoinPoint pjp){        Object rtValue = null;        try{//           1、获取参数           Object[] args = pjp.getArgs();//           2、开启事务            this.beginTransaction();//           3、执行方法            rtValue = pjp.proceed(args);//            4、提交事务            this.commit();//            5、返回结果            return rtValue;        }catch(Throwable e){//            回滚事务            this.rollback();            throw new RuntimeException(e);        }        finally{//           释放资源            this.release();        }    }}</code></pre><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--    配置Spring创建容器时需要扫描的包--&gt;    &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--配置QueryRunner--&gt;    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;    &lt;/bean&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!--连接数据库的必备信息--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy?characterEncoding=utf8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=false&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--开启Spring对注解AOP的支持--&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;</code></pre><hr><pre><code>package com.itheima.test;        import com.itheima.domain.Account;        import com.itheima.service.IAccountService;        import org.junit.Test;        import org.junit.runner.RunWith;        import org.springframework.beans.factory.annotation.Autowired;        import org.springframework.beans.factory.annotation.Qualifier;        import org.springframework.test.context.ContextConfiguration;        import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;        import java.util.List;/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)public class AccountServiceTest {    @Autowired    private  IAccountService as;    @Test    public void testTransfer(){        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);    }}</code></pre><hr><hr><hr><p>在注解配置银行案例的情况下，有一个小问题就是Spring容器自己配置事务的时候会有一个BUG，就是他会首先执行1、connect 2、release3、提交。所以通过配置环绕注解来解决这个问题，环绕注解也就是注解都是自己配置的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;这节主要讲解了从银行转账的一个基于XML配置文件的，一个是基于注解配置的两个案例。2个都是比较完整的代码，没有测试过，可能因为数据库8.0问题导致连接不上，但是代码应该没有问题。可以作为例子深入研究一下注解和XML文件配置。&lt;/st
      
    
    </summary>
    
      <category term="Spring" scheme="http://erichunn.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://erichunn.github.io/tags/Spring/"/>
    
      <category term="事务控制" scheme="http://erichunn.github.io/tags/%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
    
      <category term="作业例子" scheme="http://erichunn.github.io/tags/%E4%BD%9C%E4%B8%9A%E4%BE%8B%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring第四天_JdbcTemplate的基本使用</title>
    <link href="http://erichunn.github.io/2019/10/05/Spring%E7%AC%AC%E5%9B%9B%E5%A4%A9_JdbcTemplate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://erichunn.github.io/2019/10/05/Spring第四天_JdbcTemplate的基本使用/</id>
    <published>2019-10-05T03:14:07.000Z</published>
    <updated>2019-10-08T14:36:01.015Z</updated>
    
    <content type="html"><![CDATA[<p>类似于dbutils</p><p><img src="https://i.imgur.com/QDvo9Qn.png" alt=""></p><p><img src="https://i.imgur.com/pnXb7t8.png" alt=""></p><p><img src="https://i.imgur.com/dSH5jGy.png" alt=""></p><p>下面是代码，我们可以通过IOC和AOP动态代理来简化这些代码。使代码更加灵活</p><p><img src="https://i.imgur.com/kdScX2O.png" alt=""></p><hr><p><strong>小tips：</strong></p><p>在使用query找到哪个是需要的方法：比如下面的这段，要找的是使用query带哪个参数的方法，先看有的返回void的有的返回List的，也就是Spring的Template是靠不同的query返回不同类型的东西，而dbUtils的query方法是靠ResultSetHandler的返回值来决定返回的内容的，</p><p>下面这个方法有这么多重载的方法，如何去定位：</p><p><img src="https://i.imgur.com/KGA79w8.png" alt=""></p><p>1、我们有什么：我们有SQL语句，语句的参数，</p><p>2、我们要什么：我们要一个返回的List集合</p><p>T类型和void类型直接就排除，然后第一个参数不是SQL语句的直接排除，然后RowMapper没有参数直接排除，一般参数就是可变参数和数组</p><p>所以最后剩下如下下图所示：<br><img src="https://i.imgur.com/lzCNz0V.png" alt=""></p><p>dbUtils的和Spring的对比：</p><p><img src="https://i.imgur.com/WmJnhQn.png" alt=""></p><hr><p>然后讲解一下JdbcTemplate的基本用法：</p><p>首先是bean.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;&lt;!--    配置jdbctemplate--&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--    配置数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306_eesy&quot;&gt;        &lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>然后是定义的domain文件：</p><pre><code>package com.itheima.domain;import java.io.Serializable;/** * @Description 账户的实体类 * @Author TT Hun * @Data 2019/10/5 11:28 */public class Account implements Serializable {    private Integer id;    private String name;    private Float money;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Float getMoney() {        return money;    }    public void setMoney(Float money) {        this.money = money;    }    @Override    public String toString() {        return &quot;Account{&quot; +                &quot;id=&quot; + id +                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +                &quot;, money=&quot; + money +                &apos;}&apos;;    }}</code></pre><p>然后是几个JdbcTemplate的Demo</p><pre><code>package com.itheima.jdbctemplate;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;/** * @Description JDBCTemplate最基本用法 * @Author TT Hun * @Data 2019/10/5 11:30 */public class JdbcTemplateDemo1 {    public static void main(String[] args) {//        准备数据源，Spring的内置数据源不通过Spring容器，来设置内置数据源。        DriverManagerDataSource ds = new DriverManagerDataSource();        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);        ds.setUrl(&quot;jdbc:mysql://localhost:3306/eesy&quot;);        ds.setUsername(&quot;root&quot;);        ds.setPassword(&quot;root&quot;);//        1、创建JDBCTemplate对象        JdbcTemplate jt = new JdbcTemplate();//        给jt设置数据源        jt.setDataSource(ds);//         2、执行操作        jt.execute(&quot;insert into account(name,money) values(&apos;ccc&apos;,1000f)&quot;);    }}</code></pre><hr><pre><code>package com.itheima.jdbctemplate;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;/** * @Description JDBCTemplate最基本用法，通过Spring容器IOC，来获取对象。 * @Author TT Hun * @Data 2019/10/5 11:30 */public class JdbcTemplateDemo2 {    public static void main(String[] args) {//        1、获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        2、获取对象        JdbcTemplate jt = ac.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);//        3、添加操作        jt.execute(&quot;insert into account(name,money) values(&apos;ddd&apos;,222f)&quot;);    }}</code></pre><hr><pre><code>package com.itheima.jdbctemplate;import com.itheima.domain.Account;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;/** * @Description JDBCTemplate的CRUD用法 * @Author TT Hun * @Data 2019/10/5 11:30 */public class JdbcTemplateDemo3 {    public static void main(String[] args) {//        1、获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        2、获取对象        JdbcTemplate jt = ac.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);//        3、执行操作//        保存操作        jt.update(&quot;insert into account(name,money)values(?,?)&quot;,&quot;eee&quot;,3333f);//        更新操作        jt.update(&quot;update acocunt set name = ?,money = ?,where id=?&quot;,&quot;test&quot;,4567,7);//        删除操作        jt.update(&quot;delete from account where id=?&quot;,8);//        查询所有//        List&lt;Account&gt; accounts = jt.query(&quot;select * from account where money &gt;?&quot;, new AccountRowMapper() , 1000f);//        下面这种方法不使用自己定义的结果集，而使用Spring自带的结果集即可。        List&lt;Account&gt; accounts = jt.query(&quot;select * from account where money&gt;?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class) , 1000f);        for (Account account:accounts){            System.out.println(account);        }//        查询一个        List&lt;Account&gt; account = jt.query(&quot;select * from account where id=?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class) , 1);        System.out.println(accounts.isEmpty()? &quot;没有内容&quot;:accounts.get(0));//        查询返回一行一列(使用聚合函数但是不加groupby字句)        List&lt;Long&gt; count = jt.queryForList(&quot;select count(*) from account where money &gt; ? &quot;, Long.class, 100000f);        System.out.println(count);    }}/** * 定义Account的封装策略的 */class AccountRowMapper implements RowMapper&lt;Account&gt; {    /**     * 把结果集中的数据封装到Account中然后由Spring把每个Account加到集合中     * @param rs     * @param rowNum     * @return     * @throws SQLException     */    public Account mapRow(ResultSet rs, int rowNum) throws SQLException {        Account account = new Account();        account.setId(rs.getInt(&quot;id&quot;));        account.setName(rs.getString(&quot;name&quot;));        account.setMoney(rs.getFloat(&quot;money&quot;));        return account;    }}</code></pre><hr><p>测试类使用Dao层的操作：</p><pre><code>import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;/** * @Description JDBCTemplate最基本用法，通过Spring容器IOC，来获取对象。 * @Author TT Hun * @Data 2019/10/5 11:30 */public class test {    public static void main(String[] args) {//        1、获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        2、获取对象//        JdbcTemplate accountDao = ac.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);//        3、添加操作//        jt.execute(&quot;insert into account(name,money) values(&apos;ddd&apos;,222f)&quot;);        IAccountDao ad = ac.getBean(&quot;accountDao&quot;, IAccountDao.class);        Account account = ad.findAccountById(1);        System.out.println(account);    }}</code></pre><p>和上面测试类一起的</p><pre><code>package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import java.util.List;/** * @Description 账户的持久层实现类 * @Author TT Hun * @Data 2019/10/8 21:05 */public class AccountDaoImpl implements IAccountDao {    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {        this.jdbcTemplate = jdbcTemplate;    }    public Account findAccountById(Integer accountId) {         List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account where id = ? &quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);         return accounts.isEmpty()? null:accounts.get(0);    }    public Account findAccountByName(String accountName) {        List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account where name = ? &quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);        if(accounts.isEmpty()){            return null;        }        if(accounts.size()&gt;1){            throw new RuntimeException(&quot;结果集不唯一&quot;);        }        return accounts.get(0);    }    public void updateAccount(Account account) {        jdbcTemplate.update(&quot;update account set name=?,money = ? where id = ?&quot;,account.getName(),account.getMoney(),account.getId());    }}</code></pre><hr><hr><hr><p>通常情况下，不仅仅有一个AccountDaoImpl，还会有有一些其他的impl，比如用户的。。之类的。<br>所以需要把重复代码抽取出来也就是让他们继承一个父类，父类中写好了重复代码即可：</p><p><img src="https://i.imgur.com/uoAnOLH.png" alt=""></p><p>也就是通过继承的方式实现重复代码的抽取，一种是注入dataSource一种是注入JdbcTemplate</p><p><img src="https://i.imgur.com/7ukvCYs.png" alt=""></p><p>除了字节写继承父类的方式解决这个问题，还可以通过Spring自带的一个类来解决，直接继承jdbcDaoSupport类即可。<br><img src="https://i.imgur.com/939epiM.png" alt=""></p><p>也就是说根本不需要自己写这个父类，直接继承Spring自带的父类即可。</p><p>所以，现在有2种写法，一种是继承父类，一种是成员变量，区别是：<br>继承的方法适合用xml文件配置的方式来写，而写成员变量适合用注解的方式来开发；<br>而继承父类因为父类在jar包里面，所以不能注入。<br><img src="https://i.imgur.com/lGpsHsd.png" alt=""><br><img src="https://i.imgur.com/QH8Ltnm.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类似于dbutils&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QDvo9Qn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/pnXb7t8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
      <category term="Spring" scheme="http://erichunn.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://erichunn.github.io/tags/Spring/"/>
    
      <category term="JdbcTemplate" scheme="http://erichunn.github.io/tags/JdbcTemplate/"/>
    
  </entry>
  
  <entry>
    <title>Spring第三天天_面向切片编程AOP</title>
    <link href="http://erichunn.github.io/2019/10/04/Spring%E7%AC%AC%E4%B8%89%E5%A4%A9-%E9%9D%A2%E5%90%91%E5%88%87%E7%89%87%E7%BC%96%E7%A8%8BAOP/"/>
    <id>http://erichunn.github.io/2019/10/04/Spring第三天-面向切片编程AOP/</id>
    <published>2019-10-04T01:40:21.000Z</published>
    <updated>2019-10-04T17:47:05.325Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/X6RlFpQ.png" alt=""></p><p><img src="https://i.imgur.com/Bd6rf5q.png" alt=""></p><p>下图：开始配置serviceimpl到容器中，在配置Logger类，然后配置AOP，将logger类配置到AOP中，<br>配置通知类型，建立通知方法和切入点关联，就是用printLog方法执行在AccountServiceimpl.saveAccount()方法前面。也就是每次执行那个saveAccount方法时候，都要通过prinLog方法，也就是使用动态代理完成</p><p><img src="https://i.imgur.com/uN37a9u.png" alt=""></p><hr><hr><hr><pre><code>package com.itheima.service;/** * @Description 账户的业务层接口 * @Author TT Hun * @Data 2019/10/4 17:31 */public interface IAccountService {    /**     * 模拟保存账户     */    void saveAccount();    /**     * 模拟更新账户     */    void updateAccount(int i);    /**     * 模拟删除账户     * @return     */    int deleteAccount();}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.service.IAccountService;/** * @Description TODO * @Author TT Hun * @Data 2019/10/4 17:35 */public class accountServiceImpl implements IAccountService {    public void saveAccount() {        System.out.println(&quot;执行了保存&quot; );    }    public void updateAccount(int i) {    System.out.println(&quot;执行了更新&quot; + i );    }    public int deleteAccount() {        System.out.println(&quot;执行了删除&quot;);        return 0;    }}</code></pre><hr><pre><code>package com.itheima.utils;/** * @Description 用于记录日志的工具类，提供了公共的代码 * @Author TT Hun * @Data 2019/10/4 17:37 */public class Logger {    /**     * 用于打印日志，计划让其在切入点方法之前执行（切入点方法就是我们的业务层昂法）     */    public void printLog(){        System.out.println(&quot;Logger类中的Printlog方法开始记录日志了&quot;);    }}</code></pre><hr><p>bean.xml文件配置：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!--    配置Springioc把service对象配置进来--&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.accountServiceImpl&quot;&gt;&lt;/bean&gt;&lt;!--    spring中基于xml的AOP配置步骤--&gt;&lt;!--    1、把通知的bean也交给Spring来管理--&gt;&lt;!--    2、使用aopconfig标签表明开始AOP的配置        3、使用aop:aspect的标签表明配置切面                id属性：是给切面提供一个唯一标识                ref属性：指定通知类bean的id         4、在aop:aspect标签的内部使用对应的标签来配置通知的类型                我们现在示例是让printlog方法在切入点方法之前执行，所以是前置通知                使用aop:before标签表示配置前置通知                method属性用于指定logger类中哪个方法是前置通知                pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中那些方法进行增强                切入点表达式的写法：                关键字：execution(表达式)                表达式写法：                访问修饰符   返回值  包名.包名.包名......类名.方法名(参数列表)                标准表达式写法：                        public void com.itheima.service.impl.AccountServiceImpl.saveAccount()                返回值可以使用通配符表示任意返回值                        全通配切入点表达式写法、返回值是*然后所有的也是*：                            * *..*.*(..)                         包名可以使用..表示当前包及其子包。表示所有包下面只要有这个方法的                            * *..AccountServiceImpl.saveAccount()                         类名和方法名都可以使用*来实现通配                         * *..*.*()                         参数列表，可以直接写数据类型：                                基本类型直接写名称               int                                引用类型写包名.类名的方式       java.lang.String                                可以使用通配符表示任意类型，但是必须有参数 *                         实际开发中切入点表达式额通常写法：                                切到业务层实现类下的所有方法                                * com.itheima.service.impl.*.*(..)                --&gt;&lt;!--    配置logger类--&gt;    &lt;bean id=&quot;logger&quot; class=&quot;com.itheima.utils.Logger&quot;&gt;&lt;/bean&gt;&lt;!--    配置Aop--&gt;    &lt;aop:config&gt;&lt;!--        配置切面--&gt;        &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;&lt;!--            配置通知的类型且建立通知方法和切入点方法的关联--&gt;            &lt;aop:before method=&quot;printLog&quot; pointcut=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;    &lt;/beans&gt;</code></pre><hr><hr><hr><p>下面是前置通知、后置通知、异常通知、最终通知在AOP里面的配置</p><p><img src="https://i.imgur.com/SQA6PUp.png" alt=""></p><p><img src="https://i.imgur.com/Bd6rf5q.png" alt=""></p><hr><p><strong>环绕通知的配置</strong>：</p><p>在xml文件里面吧前置、后置、异常、最终都注释掉。然后在Logger类中通过代码控制，实现动态代理，解决前置，后置，异常，最终的问题。也就是除了通过配置xml文件中配置实现这些，也可以靠自己编码实现</p><p>1、实现bean.xml文件只保留环绕的切面配置：</p><p><img src="https://i.imgur.com/ZRoQGKr.png" alt=""></p><p>2、在Logger里面aroundPringLog()方法写前置后置等。</p><pre><code>package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;/** * @Description 用于记录日志的工具类，提供了公共的代码 * @Author TT Hun * @Data 2019/10/4 17:37 */public class Logger {    /**     * 后置通知     */    public void afterReturningPrintLog() {        System.out.println(&quot;后置通知Logger类中的afterReturningPrintLog方法开始记录日志了&quot;);    }    /**     * 前置通知     */    public void beforePrintLog() {        System.out.println(&quot;前置通知Logger类中的Printlog方法开始记录日志了&quot;);    }    /**     * 异常通知     */    public void afterThrowingPrintLog() {        System.out.println(&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了&quot;);    }    /**     * 最终通知     */    public void afterPrintLog() {        System.out.println(&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了&quot;);    }    /**     * 环绕通知     * 问题：当我们配置了环绕通知之后切入点方法没有执行，而通知方法执行了。     * 分析：通过对比动态代理中的环绕通知代码，发现动态代理中的环绕通知有明确的切入点方法调用，而我们的代码中没有。     * 解决：     *          Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法叫proceed(),此方法就相当于明确调用切入点方法。     *          该接口可以作为环绕通知的方法参数，在程序执行时候，spring框架会为我们提供该接口的实现类供我们使用。     *     *  Spring中的环绕通知：     *          他是spring框架为我们提供的一种方式：可以在代码中手动控制增强方法何时执行的方式。     *     *     *          也就是除了配置在bean.xml文件中，实现动态代理，解决前置，后置，异常，最终的问题     *          也可以通过代码控制的方式。     */    public Object aroundPringLog(ProceedingJoinPoint pjp){        Object rtValue = null;        try {            System.out.println(&quot;Logger类中的afterPrintLog方法开始记录日志了。。。前置&quot;);           rtValue = pjp.getArgs();//得到方法执行所需要的参数            System.out.println(&quot;Logger类中的afterPrintLog方法开始记录日志了。。。后置&quot;);            pjp.proceed();//明确调用业务层方法，也叫切入点方法            return rtValue;        } catch (Throwable t) {            System.out.println(&quot;Logger类中的afterPrintLog方法开始记录日志了。。。异常&quot;);            throw  new RuntimeException();        }        finally {            System.out.println(&quot;Logger类中的afterPrintLog方法开始记录日志了。。。最终&quot;);        }    }}</code></pre><hr><h1 id="Spring基于注解的AOP配置"><a href="#Spring基于注解的AOP配置" class="headerlink" title="Spring基于注解的AOP配置"></a>Spring基于注解的AOP配置</h1><p>首先使用注解的AOP配置会有一个问题：就是这几个通知的顺序问题。有可能顺序错乱，这个是Spring自己的问题：</p><p><img src="https://i.imgur.com/eaaNP9W.png" alt=""></p><p>但是使用环绕通知是没有这个问题的：</p><p><img src="https://i.imgur.com/6Ht4ifM.png" alt=""></p><p>所以如果使用注解AOP的话建议使用环绕模式的：</p><p>完整代码如下：</p><pre><code>package com.itheima.service.impl;import com.itheima.service.IAccountService;import org.springframework.stereotype.Service;/** * @Description TODO * @Author TT Hun * @Data 2019/10/4 17:35 */@Service(&quot;accountService&quot;)public class accountServiceImpl implements IAccountService {    public void saveAccount() {        System.out.println(&quot;执行了保存&quot; );    }    public void updateAccount(int i) {    System.out.println(&quot;执行了更新&quot; + i );    }    public int deleteAccount() {        System.out.println(&quot;执行了删除&quot;);        return 0;    }}</code></pre><hr><pre><code>package com.itheima.service;/** * @Description 账户的业务层接口 * @Author TT Hun * @Data 2019/10/4 17:31 */public interface IAccountService {    /**     * 模拟保存账户     */    void saveAccount();    /**     * 模拟更新账户     */    void updateAccount(int i);    /**     * 模拟删除账户     * @return     */    int deleteAccount();}</code></pre><hr><pre><code>package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * @Description 用于记录日志的工具类，提供了公共的代码 * @Author TT Hun * @Data 2019/10/4 17:37 */@Component(&quot;Logger&quot;)@Aspect//表示当前类是一个切面类public class Logger {    @Pointcut(&quot;execution(* com.itheima.service.impl.*.*())&quot;)    private void pt1(){}    /**     * 后置通知     */    @AfterReturning(&quot;pt1()&quot;)    public void afterReturningPrintLog() {        System.out.println(&quot;后置通知Logger类中的afterReturningPrintLog方法开始记录日志了&quot;);    }    /**     * 前置通知     */    @Before(&quot;pt1()&quot;)    public void beforePrintLog() {        System.out.println(&quot;前置通知Logger类中的Printlog方法开始记录日志了&quot;);    }    /**     * 异常通知     */    @AfterThrowing(&quot;pt1()&quot;)    public void afterThrowingPrintLog() {        System.out.println(&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了&quot;);    }    /**     * 最终通知     */    @After(&quot;pt1()&quot;)    public void afterPrintLog() {        System.out.println(&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了&quot;);    }    /**     * 环绕通知     * 问题：当我们配置了环绕通知之后切入点方法没有执行，而通知方法执行了。     * 分析：通过对比动态代理中的环绕通知代码，发现动态代理中的环绕通知有明确的切入点方法调用，而我们的代码中没有。     * 解决：     *          Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法叫proceed(),此方法就相当于明确调用切入点方法。     *          该接口可以作为环绕通知的方法参数，在程序执行时候，spring框架会为我们提供该接口的实现类供我们使用。     *     *  Spring中的环绕通知：     *          他是spring框架为我们提供的一种方式：可以在代码中手动控制增强方法何时执行的方式。     *     *     *          也就是除了配置在bean.xml文件中，实现动态代理，解决前置，后置，异常，最终的问题     *          也可以通过代码控制的方式。     *///    @Around(&quot;pt1()&quot;)    public Object aroundPringLog(ProceedingJoinPoint pjp){        Object rtValue = null;        try {            System.out.println(&quot;Logger类中的afterPrintLog方法开始记录日志了。。。前置&quot;);           rtValue = pjp.getArgs();//得到方法执行所需要的参数            System.out.println(&quot;Logger类中的afterPrintLog方法开始记录日志了。。。后置&quot;);            pjp.proceed();//明确调用业务层方法，也叫切入点方法            return rtValue;        } catch (Throwable t) {            System.out.println(&quot;Logger类中的afterPrintLog方法开始记录日志了。。。异常&quot;);            throw  new RuntimeException();        }        finally {            System.out.println(&quot;Logger类中的afterPrintLog方法开始记录日志了。。。最终&quot;);        }    }}</code></pre><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 配置spring创建容器时要扫描的包--&gt;    &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 配置spring开启注解AOP的支持 --&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;</code></pre><hr><pre><code>package com.itheima;import com.itheima.service.IAccountService;import javafx.application.Application;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @Description 测试AOP的配置 * @Author TT Hun * @Data 2019/10/4 18:58 */public class test {    public static void main(String[] args) {//        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        2、获取对象        IAccountService as = (IAccountService)ac.getBean(&quot;accountService&quot;);//        3、执行方法        as.saveAccount();}}</code></pre><hr><hr><hr><p>总结内容：<br>1、从银行转行入手<br>由于加了事务，导致非常麻烦，重复代码非常多，首先：</p><p>第一步是将重复的代码，事务的解决抽取出来，</p><p>然后：是将代码通过动态代理加入到源代码中，动态代理的好处是可以不改变源码的基础上，对已有的代码进行增强。</p><p>然后讲解了两种动态代理方式：一种基于子类的动态代理，一种基于接口的动态代理。</p><p>再后，通过Springaop实现动态代理。这里面有一些术语需要消化。</p><p><img src="https://i.imgur.com/1P9AwN6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/X6RlFpQ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Bd6rf5q.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下图：开始配置serviceimpl到容器
      
    
    </summary>
    
      <category term="SpringAOP" scheme="http://erichunn.github.io/categories/SpringAOP/"/>
    
    
      <category term="SpringAOP" scheme="http://erichunn.github.io/tags/SpringAOP/"/>
    
      <category term="面向切片编程" scheme="http://erichunn.github.io/tags/%E9%9D%A2%E5%90%91%E5%88%87%E7%89%87%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Spring第三天" scheme="http://erichunn.github.io/tags/Spring%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>Spring第三天_银行转账案例</title>
    <link href="http://erichunn.github.io/2019/10/02/Spring%E7%AC%AC%E4%B8%89%E5%A4%A9-%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E6%A1%88%E4%BE%8B/"/>
    <id>http://erichunn.github.io/2019/10/02/Spring第三天-银行转账案例/</id>
    <published>2019-10-02T14:39:06.000Z</published>
    <updated>2019-10-03T16:56:28.064Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/KTxFDiv.png" alt=""></p><p>数据库配置问题：<br>在bean.xml文件里面写配置的时候，中间要加分号图1是正确的图2是错误的<br><img src="https://i.imgur.com/55lCGQC.png" alt=""></p><p><img src="https://i.imgur.com/6fQopwA.png" alt=""></p><hr><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import java.util.List;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);    /**     * 根据名称查账户     * @param accountName   用户名称     * @return      如果有唯一结果就返回，如果没有结果就返回Null,结果集超过一个返回异常     */    Account findAccountByName(String accountName);}</code></pre><hr><pre><code>package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.junit.runner.Runner;import java.util.List;/** * 账户的持久层实现类 */public class AccountDaoImpl implements IAccountDao {    private QueryRunner runner;    public void setRunner(QueryRunner runner) {        this.runner = runner;    }    public List&lt;Account&gt; findAllAccount() {        try {            return runner.query(&quot;select * from account&quot;, new BeanListHandler&lt;Account&gt;(Account.class));        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountById(Integer accountId) {        try {            return runner.query(&quot;select * from account where id = ? &quot;, new BeanHandler&lt;Account&gt;(Account.class), accountId);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void saveAccount(Account account) {        try {            runner.update(&quot;insert into account(name,money)values(?,?)&quot;, account.getName(), account.getMoney());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void updateAccount(Account account) {        try {            runner.update(&quot;update account set name=?,money=? where id=?&quot;, account.getName(), account.getMoney(), account.getId());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void deleteAccount(Integer accountId) {        try {            runner.update(&quot;delete from account where id=?&quot;, accountId);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountByName(String accountName) {        try {             List&lt;Account&gt; accounts = runner.query(&quot;select * from account where name= ? &quot;, new BeanListHandler&lt;Account&gt;(Account.class), accountName);            if(accounts == null || accounts.size()==0){                return null;            }            if(accounts.size()&gt;1){                throw new RuntimeException(&quot;结果不一致&quot;);            }            return accounts.get(0);        } catch (Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);    /**     *     * 转账方法     * @param sourceName    转出账户名称     * @param targetName    转入账户名称     * @param money         转账金额     */    void transfer(String sourceName,String targetName,Float money);</code></pre><p>}</p><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import java.util.List;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService{    private IAccountDao accountDao;    public void setAccountDao(IAccountDao accountDao) {        this.accountDao = accountDao;    }    public List&lt;Account&gt; findAllAccount() {        return accountDao.findAllAccount();    }    public Account findAccountById(Integer accountId) {        return accountDao.findAccountById(accountId);    }    public void saveAccount(Account account) {        accountDao.saveAccount(account);    }    public void updateAccount(Account account) {        accountDao.updateAccount(account);    }    public void deleteAccount(Integer acccountId) {        accountDao.deleteAccount(acccountId);    }    public void transfer(String sourceName, String targetName, Float money) {//        1、根据名称查询转出账户        Account source = accountDao.findAccountByName(sourceName);//        2、根据名称查询转入账户        Account target = accountDao.findAccountByName(targetName);//        3、转出账户减钱        source.setMoney(source.getMoney()- money);//        4、转入账户加钱        target.setMoney(target.getMoney()+money);//        5、更新转出账户        accountDao.updateAccount(source);//        6、更新转入账户        accountDao.updateAccount(target);    }}</code></pre><hr><p>bean.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 配置Service --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;        &lt;!-- 注入dao --&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置Dao对象--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;        &lt;!-- 注入QueryRunner --&gt;        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置QueryRunner--&gt;    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;        &lt;!--注入数据源--&gt;        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!--连接数据库的必备信息--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy?characterEncoding=utf8;useSSL=false;serverTimezone=UTCrewriteBatchedStatements=true&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><pre><code>package com.itheima.test;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)public class AccountServiceTest {    @Autowired    private  IAccountService as;    @Test    public void testTransfer(){        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);    }}</code></pre><hr><p>但是如果说在serviceimpl里面加入了一个报错的语句，会导致钱转出了， 但是没有转入如下图所示：</p><p><img src="https://i.imgur.com/UOkubon.png" alt=""></p><p><img src="https://i.imgur.com/j07QJUW.png" alt=""></p><h2 id="怎么解决这个事务的问题？"><a href="#怎么解决这个事务的问题？" class="headerlink" title="怎么解决这个事务的问题？"></a>怎么解决这个事务的问题？</h2><p><img src="https://i.imgur.com/9mpJpJq.png" alt=""></p><p>基本上就是每次都是创建一个新的连接，每次都没有任何关系，所以我们要让他们都在一个连接之内，要发生就都发生，要不发生就都不发生。需要对代码进行一定调整。</p><p><strong>事务控制应该都在业务层</strong></p><p>改造代码：修改Service层的代码和bean.xml的注入文件：</p><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import com.itheima.utils.TransactionManager;import java.util.List;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService {    private IAccountDao accountDao;    private TransactionManager txManger;    public void setTxManger(TransactionManager txManger) {        this.txManger = txManger;    }    public void setAccountDao(IAccountDao accountDao) {        this.accountDao = accountDao;    }    public List&lt;Account&gt; findAllAccount() {        try {//            1、开启事务，            txManger.beginTransaction();//            2、执行操作            List&lt;Account&gt; accounts = accountDao.findAllAccount();//            3、提交事务            txManger.commit();//            4、返回结果            return accounts;        } catch (Exception e) {//             5、回滚操作            txManger.rollback();        } finally {//             6、释放资源            txManger.release();        }        return null;    }    public Account findAccountById(Integer accountId)    {        try {//            1、开启事务，            txManger.beginTransaction();//            2、执行操作            Account account = accountDao.findAccountById(accountId);//            3、提交事务            txManger.commit();//            4、返回结果            return account;        } catch (Exception e) {//             5、回滚操作            txManger.rollback();            throw new RuntimeException();        } finally {//             6、释放资源            txManger.release();        }    }    public void saveAccount(Account account) {        try {//            1、开启事务，            txManger.beginTransaction();//            2、执行操作            accountDao.saveAccount(account);//            3、提交事务            txManger.commit();//            4、返回结果        } catch (Exception e) {//             5、回滚操作            txManger.rollback();        } finally {//             6、释放资源            txManger.release();        }    }    public void updateAccount(Account account) {        try {//            1、开启事务，            txManger.beginTransaction();//            2、执行操作            accountDao.updateAccount(account);//            3、提交事务            txManger.commit();//            4、返回结果        } catch (Exception e) {//             5、回滚操作            txManger.rollback();        } finally {//             6、释放资源            txManger.release();        }    }    public void deleteAccount(Integer acccountId) {        try {//            1、开启事务，            txManger.beginTransaction();//            2、执行操作            accountDao.deleteAccount(acccountId);//            3、提交事务            txManger.commit();//            4、返回结果        } catch (Exception e) {//             5、回滚操作            txManger.rollback();        } finally {//             6、释放资源            txManger.release();        }    }    public void transfer(String sourceName, String targetName, Float money) {        try {//            1、开启事务，            txManger.beginTransaction();//            2、执行操作            //       b  1、根据名称查询转出账户            Account source = accountDao.findAccountByName(sourceName);//        2.1、根据名称查询转入账户            Account target = accountDao.findAccountByName(targetName);//        2.2、转出账户减钱            source.setMoney(source.getMoney()- money);//        2.3、转入账户加钱            target.setMoney(target.getMoney()+money);//        2.4、更新转出账户            accountDao.updateAccount(source);            int i = 1/0;//        2.5、更新转入账户            accountDao.updateAccount(target);//            3、提交事务            txManger.commit();//            4、返回结果        } catch (Exception e) {//             5、回滚操作            txManger.rollback();        } finally {//             6、释放资源            txManger.release();        }    }}</code></pre><hr><p>bean.xml文件：</p><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 配置Service --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;        &lt;!-- 注入dao --&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;        &lt;!--注入事务管理器--&gt;        &lt;property name=&quot;txManger&quot; ref=&quot;txManager&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置Dao对象--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;        &lt;!-- 注入QueryRunner --&gt;        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;&lt;!--        注入ConnectionUtils--&gt;        &lt;property name=&quot;connectionUtils&quot; ref =&quot;connectionUtils&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置QueryRunner--&gt;    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;    &lt;/bean&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!--连接数据库的必备信息--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy?localhost:3306/eesy?characterEncoding=utf-8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=false&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--    配置Connection的工具类 ConnectionUtils--&gt;    &lt;bean id =&quot;connectionUtils&quot; class =&quot;com.itheima.utils.ConnectionUtils&quot;&gt;&lt;!--        注入数据源--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--    配置事务管理器--&gt;    &lt;bean id=&quot;txManager&quot; class=&quot;com.itheima.utils.TransactionManager&quot;&gt;&lt;!--        注入ConnectionUtils--&gt;        &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;     </code></pre><hr><p>添加Connectionutils类：</p><pre><code>package com.itheima.utils;import javax.sql.DataSource;import java.sql.Connection;/** * @Description 连接的工具类，用于从数据源中获取一个连接，并且实现和线程的绑定 * @Author TT Hun * @Data 2019/10/3 11:22 */public class ConnectionUtils {    private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();    private DataSource dataSource;    public void setDataSource(DataSource dataSource) {        this.dataSource = dataSource;    }    /**     * 获取当前线程上的链接     *     * @return     */    public Connection getThreadConnection() {//        1、先从ThreadLocal上获取        Connection conn = tl.get();//        2、判断当前线程上是否有链接        try {            if (conn == null) {//        3、从数据源中获取一个连接，并且存入ThreadLocalz中                conn = dataSource.getConnection();                tl.set(conn);            }//        4、返回当前线程上的连接            return conn;        } catch (Exception e) {            throw new RuntimeException(&quot;报错了&quot;);        }    }    /**     * 链接和线程解绑     */    public void removeConnection(){        tl.remove();    }}</code></pre><p>添加TransactionManager类：</p><pre><code>package com.itheima.utils;/** * @Description 和事务管理相关的工具类，包含了开启事务，提交事务，回滚事务和释放连接的方法 * @Author TT Hun * @Data 2019/10/3 11:35 */public class TransactionManager {    private ConnectionUtils connectionUtils;    public void setConnectionUtils(ConnectionUtils connectionUtils) {        this.connectionUtils = connectionUtils;    }    /**     * 开始事务     */    public void beginTransaction() {        try {            connectionUtils.getThreadConnection().setAutoCommit(false);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 提交事务     */    public void commit() {        try {            connectionUtils.getThreadConnection().commit();        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 回滚事务     */    public void rollback() {        try {            connectionUtils.getThreadConnection().rollback();        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 释放连接事务     */    public void release() {        try {//            使用服务器也有一个线程池，当tomcat启动时候，会初始化一大堆线程放到一个容器中//            每次访问都是线程池中拿出来一个线程给我们使用，调用close方法并不是真正的关闭而是将线程还给线程池            connectionUtils.getThreadConnection().close();//            所以想要连接和线程解绑，通过这个方法。            connectionUtils.removeConnection();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><hr><p>再使用test类测试：</p><pre><code>package com.itheima.test;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)public class AccountServiceTest {    @Autowired    private  IAccountService as;    @Test    public void testTransfer(){        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);     }}</code></pre><hr><hr><hr><h1 id="基于接口的动态代理回顾"><a href="#基于接口的动态代理回顾" class="headerlink" title="基于接口的动态代理回顾"></a>基于接口的动态代理回顾</h1><pre><code>/** * @Description TODO * @Author TT Hun * @Data 2019/10/3 17:51 */public interface IProducer {    public void saleProduct(float money) ;    public void afterService(float money);}</code></pre><hr><pre><code>/** * @Description TODO * @Author TT Hun * @Data 2019/10/3 17:48 */public class Producer  implements IProducer{    /**     * 销售     *     * @param money     */    public void saleProduct(float money) {        System.out.println(&quot;销售产品，并且拿到钱&quot; + money);    }    /**     * 售后     *     * @param money     */    public void afterService(float money) {        System.out.println(&quot;提供售后服务并拿到钱&quot; + money);    }}</code></pre><hr><pre><code>import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Properties;/** * @Description 模拟一个消费者 * @Author TT Hun * @Data 2019/10/3 17:52 */public class Client {    public static void main(String[] args) {        final Producer producer = new Producer();        /**         * 动态代理：         *      特点：字节码随用随创建，随用随加载         *      作用：不修改源码的基础上对方法进行增强         *      分类：基于接口的动态代理         *             基于子类的动态代理         *         *       基于接口的动态代理：涉及的类：Proxy         *                           提供者：官方         *         *        如何创建爱代理对象：使用Porxy类中的newProxyInstance方法         *        创建代理对象的要求：被代理类最少实现一个接口，如果没有则不能使用         *         *        newProxyInstance方法的参数;         *        Classloader：用于加载代理对象字节码的。写的是被代理对象使用相同的类加载器。代理谁就写谁的classloader固定写法         *        Class[]：是字节码数组，让代理对象和被代理对象有相同的方法。固定写法         *        InvocationHandler：用于提供增强的代码。他是让我们写如何代理。我们一般都是写一个该接口的实现类，通常都是匿名内         *        部类，但是不必须的。此接口的实现类都是谁用谁写，         *         */         IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() {             /**              * 作用：执行被代理对象的任何接口方法都会经过该方法，该方法就会有拦截的功能              * 方法参数的含义              * @param proxy ：代理对象的引用              * @param method： 表示当前执行的方法              * @param args ：当前执行方法所需要的参数              * @return     和被代理对象有相同的返回值              * @throws Throwable              * 内部类访问外部对象时候要求外部对象是final的              */            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {//                提供增强的代码                Object returnValue = null;//                1、获取方法执行的参数                Float money = (Float)args[0];//                2、判断当前方法是不是销售方法                if(&quot;saleProduct&quot;.equals(method.getName())){                   returnValue = method.invoke(producer,money*0.8f);                }                return returnValue;            }        });         proxyProducer.saleProduct(10000f);    }}</code></pre><hr><p><strong>上述有一个问题：如果类不实现任何接口的时候是不能使用的</strong></p><h1 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h1><p>要求有第三方jar包的支持 cglib包</p><pre><code>package com.itheima.cglib;/** * @Description TODO * @Author TT Hun * @Data 2019/10/3 17:48 */public class Producer    {    /**     * 销售     *     * @param money     */    public void saleProduct(float money) {        System.out.println(&quot;销售产品，并且拿到钱&quot; + money);    }    /**     * 售后     *     * @param money     */    public void afterService(float money) {        System.out.println(&quot;提供售后服务并拿到钱&quot; + money);    }}</code></pre><hr><pre><code>package com.itheima.cglib;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @Description 模拟一个消费者 * @Author TT Hun * @Data 2019/10/3 17:52 */public class Client {    public static void main(String[] args) {        final Producer producer = new Producer();        /**         * 动态代理：         *      特点：字节码随用随创建，随用随加载         *      作用：不修改源码的基础上对方法进行增强         *      分类：基于接口的动态代理         *             基于子类的动态代理         *         *       基于子类的动态代理：涉及的类：Enhancer         *                           提供者：第三方cglib库         *         *        如何创建爱代理对象：使用Enhancer类中的create方法         *        创建代理对象的要求：被代理不能是最终类         *         *        create方法的参数;         *        class：字节码         *              用于指定被代理对象的字节码。         *         callback:用于提供增强的代码         *                  他是让我们写如何代理，我们一般都是写改接口的子接口实现类：MethodInterceptor         *         */       Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() {//            执行被代理对象任何方法都会经过该方法            /**             *             * @param o             * @param method             * @param args             * 以上三个参数和基于接口的对象代理Invoke的代理参数是一样的             * @param methodProxy：当前执行方法的代理对象             * @return             * @throws Throwable             */            public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {//                提供增强的代码                Object returnValue = null;//                1、获取方法执行的参数                Float money = (Float) args[0];//                2、判断当前方法是不是销售方法                if (&quot;saleProduct&quot;.equals(method.getName())) {                    returnValue = method.invoke(producer, money * 0.8f);                }                return returnValue;            }        });       cglibProducer.saleProduct(12000f);    }}</code></pre><hr><p>动态代理的作用：</p><pre><code>1、连接池那个地方就是close不能关闭连接，只能将线程放到线程池，可以通过动态代理解决对connection的close()方法进行增强。把它家回到池里面去。2、解决全栈中文乱码的问题，对其中的3个方法进行增强。</code></pre><p>下面一段代码是通过动态代理但是不通过AOP解决事务的问题、解决重复代码，解决了方法之间的依赖，但是导致配置文件bean.xml里面的配置比较繁琐。以下是标准的使用动态代理控制事务解决银行问题的代码，是标准代码，但是我自己由于数据库问题没有运行成功：</p><pre><code>package com.itheima.dao.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.util.List;/** * 账户的持久层实现类 */public class AccountDaoImpl implements IAccountDao {    private QueryRunner runner;    private ConnectionUtils connectionUtils;    public void setRunner(QueryRunner runner) {        this.runner = runner;    }    public void setConnectionUtils(ConnectionUtils connectionUtils) {        this.connectionUtils = connectionUtils;    }    public List&lt;Account&gt; findAllAccount() {        try{            return runner.query(connectionUtils.getThreadConnection(),&quot;select * from account&quot;,new BeanListHandler&lt;Account&gt;(Account.class));        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountById(Integer accountId) {        try{            return runner.query(connectionUtils.getThreadConnection(),&quot;select * from account where id = ? &quot;,new BeanHandler&lt;Account&gt;(Account.class),accountId);        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public void saveAccount(Account account) {        try{            runner.update(connectionUtils.getThreadConnection(),&quot;insert into account(name,money)values(?,?)&quot;,account.getName(),account.getMoney());        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public void updateAccount(Account account) {        try{            runner.update(connectionUtils.getThreadConnection(),&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId());        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public void deleteAccount(Integer accountId) {        try{            runner.update(connectionUtils.getThreadConnection(),&quot;delete from account where id=?&quot;,accountId);        }catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountByName(String accountName) {        try{            List&lt;Account&gt; accounts = runner.query(connectionUtils.getThreadConnection(),&quot;select * from account where name = ? &quot;,new BeanListHandler&lt;Account&gt;(Account.class),accountName);            if(accounts == null || accounts.size() == 0){                return null;            }            if(accounts.size() &gt; 1){                throw new RuntimeException(&quot;结果集不唯一，数据有问题&quot;);            }            return accounts.get(0);        }catch (Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><hr><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import java.util.List;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);    /**     * 根据名称查询账户     * @param accountName     * @return  如果有唯一的一个结果就返回，如果没有结果就返回null     *          如果结果集超过一个就抛异常     */    Account findAccountByName(String accountName);}</code></pre><hr><pre><code>package com.itheima.domain;import java.io.Serializable;/** * 账户的实体类 */public class Account implements Serializable {    private Integer id;    private String name;    private Float money;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Float getMoney() {        return money;    }    public void setMoney(Float money) {        this.money = money;    }    @Override    public String toString() {        return &quot;Account{&quot; +                &quot;id=&quot; + id +                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +                &quot;, money=&quot; + money +                &apos;}&apos;;    }}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import java.util.List;/** * 账户的业务层实现类 * * 事务控制应该都是在业务层 */public class AccountServiceImpl implements IAccountService{    private IAccountDao accountDao;    public void setAccountDao(IAccountDao accountDao) {        this.accountDao = accountDao;    }    @Override    public List&lt;Account&gt; findAllAccount() {       return accountDao.findAllAccount();    }    @Override    public Account findAccountById(Integer accountId) {        return accountDao.findAccountById(accountId);    }    @Override    public void saveAccount(Account account) {        accountDao.saveAccount(account);    }    @Override    public void updateAccount(Account account) {        accountDao.updateAccount(account);    }    @Override    public void deleteAccount(Integer acccountId) {        accountDao.deleteAccount(acccountId);    }    @Override    public void transfer(String sourceName, String targetName, Float money) {        System.out.println(&quot;transfer....&quot;);            //2.1根据名称查询转出账户            Account source = accountDao.findAccountByName(sourceName);            //2.2根据名称查询转入账户            Account target = accountDao.findAccountByName(targetName);            //2.3转出账户减钱            source.setMoney(source.getMoney()-money);            //2.4转入账户加钱            target.setMoney(target.getMoney()+money);            //2.5更新转出账户            accountDao.updateAccount(source);//            int i=1/0;            //2.6更新转入账户            accountDao.updateAccount(target);    }}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);    /**     * 转账     * @param sourceName        转出账户名称     * @param targetName        转入账户名称     * @param money             转账金额     */    void transfer(String sourceName,String targetName,Float money);    //void test();//它只是连接点，但不是切入点，因为没有被增强}</code></pre><hr><pre><code>package com.itheima.utils;import javax.sql.DataSource;import java.sql.Connection;/** * 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定 */public class ConnectionUtils {    private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;();    private DataSource dataSource;    public void setDataSource(DataSource dataSource) {        this.dataSource = dataSource;    }    /**     * 获取当前线程上的连接     * @return     */    public Connection getThreadConnection() {        try{            //1.先从ThreadLocal上获取            Connection conn = tl.get();            //2.判断当前线程上是否有连接            if (conn == null) {                //3.从数据源中获取一个连接，并且存入ThreadLocal中                conn = dataSource.getConnection();                tl.set(conn);            }            //4.返回当前线程上的连接            return conn;        }catch (Exception e){            throw new RuntimeException(e);        }    }    /**     * 把连接和线程解绑     */    public void removeConnection(){        tl.remove();    }}</code></pre><hr><pre><code>package com.itheima.utils;/** * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接 */public class TransactionManager {    private ConnectionUtils connectionUtils;    public void setConnectionUtils(ConnectionUtils connectionUtils) {        this.connectionUtils = connectionUtils;    }    /**     * 开启事务     */    public  void beginTransaction(){        try {            connectionUtils.getThreadConnection().setAutoCommit(false);        }catch (Exception e){            e.printStackTrace();        }    }    /**     * 提交事务     */    public  void commit(){        try {            connectionUtils.getThreadConnection().commit();        }catch (Exception e){            e.printStackTrace();        }    }    /**     * 回滚事务     */    public  void rollback(){        try {            connectionUtils.getThreadConnection().rollback();        }catch (Exception e){            e.printStackTrace();        }    }    /**     * 释放连接     */    public  void release(){        try {            connectionUtils.getThreadConnection().close();//还回连接池中            connectionUtils.removeConnection();        }catch (Exception e){            e.printStackTrace();        }    }}</code></pre><hr><pre><code>package com.itheima.factory;import com.itheima.service.IAccountService;import com.itheima.utils.TransactionManager;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 用于创建Service的代理对象的工厂 */public class BeanFactory {    private IAccountService accountService;    private TransactionManager txManager;    public void setTxManager(TransactionManager txManager) {        this.txManager = txManager;    }    public final void setAccountService(IAccountService accountService) {        this.accountService = accountService;    }    /**     * 获取Service代理对象     * @return     */    public IAccountService getAccountService() {        return (IAccountService)Proxy.newProxyInstance(accountService.getClass().getClassLoader(),                accountService.getClass().getInterfaces(),                new InvocationHandler() {                    /**                     * 添加事务的支持                     *                     * @param proxy                     * @param method                     * @param args                     * @return                     * @throws Throwable                     */                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {//                        if(&quot;test&quot;.equals(method.getName())){//                            return method.invoke(accountService,args);//                        }                        Object rtValue = null;                        try {                            //1.开启事务                            txManager.beginTransaction();                            //2.执行操作                            rtValue = method.invoke(accountService, args);                            //3.提交事务                            txManager.commit();                            //4.返回结果                            return rtValue;                        } catch (Exception e) {                            //5.回滚操作                            txManager.rollback();                            throw new RuntimeException(e);                        } finally {                            //6.释放连接                            txManager.release();                        }                    }                });    }}</code></pre><hr><p>bean.xml文件</p><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置代理的service--&gt;    &lt;bean id=&quot;proxyAccountService&quot; factory-bean=&quot;beanFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;    &lt;!--配置beanfactory--&gt;    &lt;bean id=&quot;beanFactory&quot; class=&quot;com.itheima.factory.BeanFactory&quot;&gt;        &lt;!-- 注入service --&gt;        &lt;property name=&quot;accountService&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt;        &lt;!-- 注入事务管理器 --&gt;        &lt;property name=&quot;txManager&quot; ref=&quot;txManager&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;     &lt;!-- 配置Service --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;        &lt;!-- 注入dao --&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置Dao对象--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;        &lt;!-- 注入QueryRunner --&gt;        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;        &lt;!-- 注入ConnectionUtils --&gt;        &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置QueryRunner--&gt;    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!--连接数据库的必备信息--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy?characterEncoding=utf8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=false&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置Connection的工具类 ConnectionUtils --&gt;    &lt;bean id=&quot;connectionUtils&quot; class=&quot;com.itheima.utils.ConnectionUtils&quot;&gt;        &lt;!-- 注入数据源--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置事务管理器--&gt;    &lt;bean id=&quot;txManager&quot; class=&quot;com.itheima.utils.TransactionManager&quot;&gt;        &lt;!-- 注入ConnectionUtils --&gt;        &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><pre><code>package com.itheima.test;import com.itheima.service.IAccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)public class AccountServiceTest {    @Autowired    @Qualifier(&quot;proxyAccountService&quot;)    private  IAccountService as;    @Test    public  void testTransfer(){        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);    }}</code></pre><hr><p>总结上述的代码；<br>utils.ConnectionUtils：获取当前线程上的连接，通过注入数据源、实例化ThreadLocal，通过ThreadLocal.get方法获取线程上的连接。<br>utils.TransactionManager:里面注入ConnectionUtils，然后写开启事务，提交事务，回滚事务，释放连接的方法<br>BeanFactory：注入Serviceimpl和TransactionManager。然后获取Service代理对象，通过getAccountService方法，并且在匿名内部类中添加事务。<br>然后在bean.xml文件里面写好要添加到各个地方的注入，然后配置代理的Service对象</p><pre><code>&lt;bean id = &quot;proxyAccountService&quot; factory-bean=&quot;beanFactory&quot; factory-method=&quot;getAccountService&quot;&gt; &lt;/bean&gt;</code></pre><p>最后在test测试类中，添加注解@Qulifier因为在bean.xml文件中有2个都实现了IAccountService接口，所以要添加Qulifier注解<br><img src="https://i.imgur.com/qT2Rgb7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/KTxFDiv.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;数据库配置问题：&lt;br&gt;在bean.xml文件里面写配置的时候，中间要加分号图1是正确的图2是错误的&lt;br&gt;&lt;img src=&quot;https://i.imgur
      
    
    </summary>
    
      <category term="Spring" scheme="http://erichunn.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://erichunn.github.io/tags/Spring/"/>
    
      <category term="银行转账案例" scheme="http://erichunn.github.io/tags/%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring第二天03Spring新注解</title>
    <link href="http://erichunn.github.io/2019/09/29/Spring%E7%AC%AC%E4%BA%8C%E5%A4%A903Spring%E6%96%B0%E6%B3%A8%E8%A7%A3/"/>
    <id>http://erichunn.github.io/2019/09/29/Spring第二天03Spring新注解/</id>
    <published>2019-09-29T11:34:41.000Z</published>
    <updated>2019-10-02T13:15:47.437Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/KDhJYiV.png" alt=""></p><p>这两个有什么区别：区别就是在XML文件里配置的东西会在Spring以Kv的形式存在    </p><hr><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import java.util.List;/** * @Description 账户的持久层实现类 * @Author TT Hun * @Data 2019/9/27 15:42 */@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao {    @Autowired    private QueryRunner runner;    public void setRunner(QueryRunner runner) {        this.runner = runner;    }    public List&lt;Account&gt; findAllAccount() {        try {            return runner.query(&quot;select * from account&quot;, new BeanListHandler&lt;Account&gt;(Account.class));        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountById(Integer accountId) {        try {            return runner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class),accountId);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void saveAccount(Account account) {        try {             runner.update(&quot;insert into account(name,money)values(?,?)&quot;, account.getName(),account.getMoney());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void updateAccount(Account account) {        try {            runner.update(&quot;update account set name =?,money = ? where id =?&quot;, account.getName(),account.getMoney(),account.getID());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void deleteAccount(Integer accountId) {        try {            runner.update(&quot;delete from  account where id = ?&quot;, accountId);        } catch (Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><hr><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import java.util.List;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);}</code></pre><hr><pre><code>package com.itheima.domain;/** * @Description TODO * @Author TT Hun * @Data 2019/9/27 15:01 */import lombok.Data;import lombok.Getter;import lombok.Setter;import java.io.Serializable;@Setter@Getter@Datapublic class Account implements Serializable {     private  Integer ID;     private  String name;     private Float money;}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 账户的业务层实现类 */@Service(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService {    @Autowired    private IAccountDao accountDao;    public List&lt;Account&gt; findAllAccount() {        return accountDao.findAllAccount();    }    public Account findAccountById(Integer accountId) {        return accountDao.findAccountById(accountId);    }    public void saveAccount(Account account) {        accountDao.saveAccount(account);    }    public void updateAccount(Account account) {        accountDao.updateAccount(account);    }    public void deleteAccount(Integer acccountId) {        accountDao.deleteAccount(acccountId);    }}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);}</code></pre><hr><pre><code>package config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;/** * @Description 和Spring连接数据库相关的配置类 * @Author TT Hun * @Data 2019/9/29 22:28 */@Configurationpublic class JdbcConfig {    /**     * 创建数据源对象     * @return     */    @Bean(&quot;dataSource&quot;)    public DataSource createDataSource() {        try {            ComboPooledDataSource ds = new ComboPooledDataSource();            ds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/eesy?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=UTC&quot;);            ds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);            ds.setUser(&quot;root&quot;);            ds.setPassword(&quot;root&quot;);            return ds;        } catch (Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><hr><pre><code>package config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.apache.commons.dbutils.QueryRunner;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import javax.sql.DataSource;/** * @Description 该类是一个配置类，他的作用和XML是一样的 * Spring中的新注解 *      Configuration:指定当前类是一个配置类 *      细节：当配置类作为AnnotationConfigApplicationContext.class对象创建的参数的时候，该注解可以不写。 *      如果有2个config的java类配置。 *      1、ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class，JdbcConfig.class) *      2、在扫描注解里面+2个路径，@ComponentScan({&quot;com.itheima&quot;,&quot;config&quot;})并且加上@Configuration。 *      但是如果是1的方式的话，2个字节码就是同等地位了，如果是SpringConfiguration作为主要的配置，JdbcConfig作为次要配置怎么办： * *      解决上面问题新注解：Import注解： *                                  作用：用于导入其他配置类 * * *      ComponentScan：用于通过注解指定spring在创建容器时要扫描的包 *      属性：value:他和basePackages的作用是一样的都是用于指定创建容器时候要扫描的包 *      我们使用此注解就等同于在xml中配置了： *       &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; * * * Bean注解： *          作用：用于把当前方法的返回值作为bean对象存入springioc的容器中。 *          属性：用于指定bean的id。当不写时默认值id是当前方法的名称value就是返回值对象new QueryRunner *          也可以在注解后面括号加上（name=&quot;runner&quot;)写上k就是runner了。加上之后和xml就一样了。 * *          细节： *          当我们使用注解配置方法时候，如果方法有参数，Spring框架回去容器中查找有没有可以用的bean对象 *          查找的方式和autowired注解是一样的， 如果有同一个类型的就注入。 * * @Author TT Hun * @Data 2019/9/29 19:51 *///@Configuration@ComponentScan({&quot;com.itheima&quot;,&quot;config&quot;})public class SpringConfiguration {    /**     * 用于创建一个QueryRunner对象     * @param dataSource     * @return     */    @Bean(name = &quot;runner&quot;)//    这个地方的细节如果没有scope的注解就是意味着单例模式，在创建QuerryRunner语句的时候可能出问题。    @Scope(&quot;prototype&quot;)    public QueryRunner createQueryRunner(DataSource dataSource) {        return new QueryRunner(dataSource);    }}</code></pre><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt;</code></pre><hr><h2 id="Import注解"><a href="#Import注解" class="headerlink" title="Import注解"></a>Import注解</h2><pre><code>package config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.apache.commons.dbutils.QueryRunner;import org.springframework.context.annotation.*;import org.springframework.stereotype.Component;import javax.sql.DataSource;/** * @Description 该类是一个配置类，他的作用和XML是一样的 * Spring中的新注解 *      Configuration:指定当前类是一个配置类 *      细节：当配置类作为AnnotationConfigApplicationContext.class对象创建的参数的时候，该注解可以不写。 *      如果有2个config的java类配置。 *      1、ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class，JdbcConfig.class) *      2、在扫描注解里面+2个路径，@ComponentScan({&quot;com.itheima&quot;,&quot;config&quot;})并且加上@Configuration。 *      但是如果是1的方式的话，2个字节码就是同等地位了，并列状态。如果是SpringConfiguration作为主要的配置，JdbcConfig作为次要配置怎么办： * *      解决上面问题新注解：Import注解： *                                  作用：用于导入其他配置类 *                                  属性：是个value，用于指定其他配置类的字节码。 *                                  但我们使用import注解之后，有Import注解的类就是主配置类。而导入的都是子配置类 * *      ComponentScan：用于通过注解指定spring在创建容器时要扫描的包 *      属性：value:他和basePackages的作用是一样的都是用于指定创建容器时候要扫描的包 *      我们使用此注解就等同于在xml中配置了： *       &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; *        * *      解决上面问题新注解：Import注解： *      作用：用于导入其他配置类     *      Import就是导入一个主要的配置类，然后其他的副的配置类 *                                * * Bean注解： *          作用：用于把当前方法的返回值作为bean对象存入springioc的容器中。 *          属性：用于指定bean的id。当不写时默认值id是当前方法的名称value就是返回值对象new QueryRunner *          也可以在注解后面括号加上（name=&quot;runner&quot;)写上k就是runner了。加上之后和xml就一样了。 * *          细节： *          当我们使用注解配置方法时候，如果方法有参数，Spring框架回去容器中查找有没有可以用的bean对象 *          查找的方式和autowired注解是一样的， 如果有同一个类型的就注入。 * * @Author TT Hun * @Data 2019/9/29 19:51 *///@Configuration@ComponentScan({&quot;com.itheima&quot;,&quot;config&quot;})@Import(JdbcConfig.class)public class SpringConfiguration {    /**     * 用于创建一个QueryRunner对象     * @param dataSource     * @return     */    @Bean(name = &quot;runner&quot;)//    这个地方的细节如果没有scope的注解就是意味着单例模式，在创建QuerryRunner语句的时候可能出问题。    @Scope(&quot;prototype&quot;)    public QueryRunner createQueryRunner(DataSource dataSource) {        return new QueryRunner(dataSource);    }}</code></pre><hr><p>但是这一行的加载配置还是要有的：</p><pre><code>Class AccountServiceTestApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);</code></pre><hr><hr><p>但是上面写的仍然有问题，问题在于</p><p><img src="https://i.imgur.com/0w5oFy0.png" alt=""></p><p>这里面的数据库配置仍然是写死的，所以仍然需要改造。。</p><p>下面是改造办法：</p><p>改造办法就是将JdbcConfig里的配置写到JdbcConfiguration里面去，然后通过@Value注解将里面的配置加载到JdbcConfig里面去。。</p><p>也就是：</p><p>jdbcConfig.properties配置文件</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesy?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=truejdbc.username=rootjdbc.password=root</code></pre><hr><pre><code>package config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;/** * @Description 和Spring连接数据库相关的配置类 * @Author TT Hun * @Data 2019/9/29 22:28 */@Configurationpublic class JdbcConfig {    @Value(&quot;${jdbc.driver}&quot;)    private String driver;    @Value(&quot;${jdbc.url}&quot;)    private String url;    @Value(&quot;${jdbc.username}&quot;)    private String username;    @Value(&quot;${jdbc.password}&quot;)    private String password;    /**     * 创建数据源对象     * @return     */    @Bean(&quot;dataSource&quot;)    public DataSource createDataSource() {            try {            ComboPooledDataSource ds = new ComboPooledDataSource();                ds.setDriverClass(driver);                ds.setJdbcUrl(url);            ds.setUser(username);            ds.setPassword(password);            return ds;        } catch (Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><hr><hr><p>这块有一个问题就是在连接数据库的时候需要使用的pom依赖：</p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-</code></pre><blockquote><p>connector-java<br>                <version>8.0.17</version><br>    </p></blockquote><hr><p>然后连接的时候写的配置需要特殊加上一些东西：</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesy?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=truejdbc.username=rootjdbc.password=root</code></pre><hr><hr><hr><h1 id="Qualifier注解的另一种用法"><a href="#Qualifier注解的另一种用法" class="headerlink" title="Qualifier注解的另一种用法"></a>Qualifier注解的另一种用法</h1><p><img src="https://i.imgur.com/1Q2lS0A.png" alt="">、<br><img src="https://i.imgur.com/IBSftQp.png" alt=""></p><hr><hr><h1 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h1><p>解决的问题：</p><p><img src="https://i.imgur.com/SkUi5nq.png" alt=""></p><p><img src="https://i.imgur.com/ocsQTl5.png" alt=""></p><p><img src="https://i.imgur.com/PIGsnyG.png" alt=""></p><p><img src="https://i.imgur.com/2WJf8Ew.png" alt=""></p><p><img src="https://i.imgur.com/yXA7G5N.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      关于Spring新注解
    
    </summary>
    
      <category term="Spring" scheme="http://erichunn.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://erichunn.github.io/tags/Spring/"/>
    
      <category term="新注解" scheme="http://erichunn.github.io/tags/%E6%96%B0%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring第二天02基于XML和使用注解的IOC案例</title>
    <link href="http://erichunn.github.io/2019/09/29/Spring%E7%AC%AC%E4%BA%8C%E5%A4%A902%E5%9F%BA%E4%BA%8EXML%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E7%9A%84IOC%E6%A1%88%E4%BE%8B/"/>
    <id>http://erichunn.github.io/2019/09/29/Spring第二天02基于XML和使用注解的IOC案例/</id>
    <published>2019-09-29T09:19:14.000Z</published>
    <updated>2019-09-29T11:26:33.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于XML的IOC的案例："><a href="#基于XML的IOC的案例：" class="headerlink" title="基于XML的IOC的案例："></a>基于XML的IOC的案例：</h1><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.util.List;/** * @Description 账户的持久层实现类 * @Author TT Hun * @Data 2019/9/27 15:42 */public class AccountDaoImpl implements IAccountDao {    private QueryRunner runner;    public void setRunner(QueryRunner runner) {        this.runner = runner;    }    public List&lt;Account&gt; findAllAccount() {        try {            return runner.query(&quot;select * from account&quot;, new BeanListHandler&lt;Account&gt;(Account.class));        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountById(Integer accountId) {        try {            return runner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class),accountId);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void saveAccount(Account account) {        try {             runner.update(&quot;insert into account(name,money)values(?,?)&quot;, account.getName(),account.getMoney());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void updateAccount(Account account) {        try {            runner.update(&quot;update account set name =?,money = ? where id =?&quot;, account.getName(),account.getMoney(),account.getID());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void deleteAccount(Integer accountId) {        try {            runner.update(&quot;delete from  account where id = ?&quot;, accountId);        } catch (Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><hr><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import java.util.List;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import java.util.List;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService{    private IAccountDao accountDao;    public void setAccountDao(IAccountDao accountDao) {        this.accountDao = accountDao;    }    public List&lt;Account&gt; findAllAccount() {        return accountDao.findAllAccount();    }    public Account findAccountById(Integer accountId) {        return accountDao.findAccountById(accountId);    }    public void saveAccount(Account account) {        accountDao.saveAccount(account);    }    public void updateAccount(Account account) {        accountDao.updateAccount(account);    }    public void deleteAccount(Integer acccountId) {        accountDao.deleteAccount(acccountId);    }}</code></pre><hr><pre><code>package com.itheima.domain;/** * @Description TODO * @Author TT Hun * @Data 2019/9/27 15:01 */import lombok.Data;import lombok.Getter;import lombok.Setter;import java.io.Serializable;@Setter@Getter@Datapublic class Account implements Serializable {     private  Integer ID;     private  String name;     private Float money;</code></pre><p>}</p><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;&lt;!--    配对业务层对象，知识点：如何创建bean对象  --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;!--        注入dao，知识点：如何注入数据、通过set方法注入数据、注入的类型：其他bean类型            这个地方由于使用了accountDao对象，所以--&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--    里面需要注入DAO对象，配置DAO对象--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.AccountDaoImpl&quot;&gt;        &lt;!--    注入queryrunner丨由于accountDaoimpl里面也是在使用了QueryRunner对象所以注入queryrunner对象--&gt;        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--配置queryrunner对象丨这个地方的细节：runner对象是一个单例对象单例对象会导致多线程在往数据库插入的时候会导致一个插入还没插入完就又开始了，相互干扰。所以加上一个scope属性，配置多例模式，--&gt;    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;&lt;!--        注入数据源、知识点：通过构造函数注入数据--&gt;        &lt;constructor-arg name=&quot;ds&quot; ref=&quot; dataSource&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;!--    配置数据源、知识点：注入的类型：基本类型的注入--&gt;    &lt;bean id=&quot; dataSource&quot; class =&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;&lt;!--        连接数据库的必备信息--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy?characterEncoding=utf-8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=false&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--总结：这个配置文件就是配置service对象和dao对象，但是由于service对象里面使用了dao对象，所以要把dao对象注入到serviceImpl里面，由于dao对象使用了dbutil的对象，所以还要注入这个对象和，然后在设置dbutil反射对象和dbutil需要注入的基本类型的数据--&gt;&lt;/beans&gt;package com.itheima.test;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;/** * @Description TODO * @Author TT Hun * @Data 2019/9/29 14:33 */public class AccountServiceTest {    @Test    public void testFindAll() {//        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);//        执行方法        List&lt;Account&gt; accounts = as.findAllAccount();        for (Account account : accounts) {            System.out.println(account);        }    }    @Test    public void testFindOne() {        //        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);//        执行方法        Account account = as.findAccountById(1);        System.out.println(account);    }    @Test    public void testSave() {        Account account = new Account();        account.setName(&quot;test&quot;);        account.setMoney(12345f);        //        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        //        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);        //         执行方法        as.saveAccount(account);    }    @Test    public void testUpdate() {        //        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);//        执行方法        Account account = new Account();        account.setMoney(23456f);        as.updateAccount(account);    }    @Test    public void testDelete() {        //        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);//        执行方法        as.deleteAccount(4);    }}</code></pre><h1 id="基于注解的IOC的案例："><a href="#基于注解的IOC的案例：" class="headerlink" title="基于注解的IOC的案例："></a>基于注解的IOC的案例：</h1><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import java.util.List;/** * 账户的持久层接口 */public interface IAccountDao {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);}</code></pre><hr><pre><code>package com.itheima.dao;import com.itheima.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import java.util.List;/** * @Description 账户的持久层实现类 * @Author TT Hun * @Data 2019/9/27 15:42 */@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao {    @Autowired    private QueryRunner runner;    public void setRunner(QueryRunner runner) {        this.runner = runner;    }    public List&lt;Account&gt; findAllAccount() {        try {            return runner.query(&quot;select * from account&quot;, new BeanListHandler&lt;Account&gt;(Account.class));        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public Account findAccountById(Integer accountId) {        try {            return runner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class),accountId);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void saveAccount(Account account) {        try {             runner.update(&quot;insert into account(name,money)values(?,?)&quot;, account.getName(),account.getMoney());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void updateAccount(Account account) {        try {            runner.update(&quot;update account set name =?,money = ? where id =?&quot;, account.getName(),account.getMoney(),account.getID());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public void deleteAccount(Integer accountId) {        try {            runner.update(&quot;delete from  account where id = ?&quot;, accountId);        } catch (Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><hr><pre><code>package com.itheima.service;import com.itheima.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService {    /**     * 查询所有     * @return     */    List&lt;Account&gt; findAllAccount();    /**     * 查询一个     * @return     */    Account findAccountById(Integer accountId);    /**     * 保存     * @param account     */    void saveAccount(Account account);    /**     * 更新     * @param account     */    void updateAccount(Account account);    /**     * 删除     * @param acccountId     */    void deleteAccount(Integer acccountId);}</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.dao.IAccountDao;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 账户的业务层实现类 */@Service(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService {    @Autowired    private IAccountDao accountDao;    public List&lt;Account&gt; findAllAccount() {        return accountDao.findAllAccount();    }    public Account findAccountById(Integer accountId) {        return accountDao.findAccountById(accountId);    }    public void saveAccount(Account account) {        accountDao.saveAccount(account);    }    public void updateAccount(Account account) {        accountDao.updateAccount(account);    }    public void deleteAccount(Integer acccountId) {        accountDao.deleteAccount(acccountId);    }}</code></pre><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--    使用注解开发就需要告知Spring在使用注解的时候需要扫描的包--&gt;    &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--配置QueryRunner--&gt;    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;        &lt;!--注入数据源--&gt;        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!--连接数据库的必备信息--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy?characterEncoding=utf-8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=false&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><pre><code>package com.itheima.test;import com.itheima.domain.Account;import com.itheima.service.IAccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;/** * @Description TODO * @Author TT Hun * @Data 2019/9/29 14:33 */public class AccountServiceTest {    @Test    public void testFindAll() {//        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);//        执行方法        List&lt;Account&gt; accounts = as.findAllAccount();        for (Account account : accounts) {            System.out.println(account);        }    }    @Test    public void testFindOne() {        //        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);//        执行方法        Account account = as.findAccountById(1);        System.out.println(account);    }    @Test    public void testSave() {        Account account = new Account();        account.setName(&quot;test&quot;);        account.setMoney(12345f);        //        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        //        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);        //         执行方法        as.saveAccount(account);    }    @Test    public void testUpdate() {        //        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);//        执行方法        Account account = new Account();        account.setMoney(23456f);        as.updateAccount(account);    }    @Test    public void testDelete() {        //        获取容器        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//        得到业务层对象        IAccountService as = ac.getBean(&quot;accountService&quot;, IAccountService.class);//        执行方法        as.deleteAccount(4);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于XML的IOC的案例：&quot;&gt;&lt;a href=&quot;#基于XML的IOC的案例：&quot; class=&quot;headerlink&quot; title=&quot;基于XML的IOC的案例：&quot;&gt;&lt;/a&gt;基于XML的IOC的案例：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;package com.itheim
      
    
    </summary>
    
      <category term="Spring" scheme="http://erichunn.github.io/categories/Spring/"/>
    
    
      <category term="SpringIOC" scheme="http://erichunn.github.io/tags/SpringIOC/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://erichunn.github.io/2019/09/25/Spring%E7%AC%94%E8%AE%B0/Spring%E4%B8%ADbean%E7%BB%86%E8%8A%82%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <id>http://erichunn.github.io/2019/09/25/Spring笔记/Spring中bean细节三种创建方式/</id>
    <published>2019-09-25T03:19:25.329Z</published>
    <updated>2019-09-26T14:13:38.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-bean的三种创建细节和生命周期"><a href="#Spring-bean的三种创建细节和生命周期" class="headerlink" title="Spring bean的三种创建细节和生命周期"></a>Spring bean的三种创建细节和生命周期</h2><p>首先如果一个类的默认构造函数是空值构造函数，然后在写一个带参构造函数，那么这个默认构造函数就被覆盖了。如下：<br>    public class AccountServiceImpl implements IAccountService {</p><pre><code>    public AccountServiceImpl(String name) {        System.out.println(&quot;对象创建了&quot;);    }}</code></pre><p>这种就是被覆盖了的构造函数</p><p> 第一种方式：使用默认构造函数创建。这种情况是使用自己写好的类</p><p> 在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。<br> 采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。</p><pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;&gt;</code></pre><p>在实际开发中有可能使用别人定义好的类，那么如何调用在Jar包里面的类呢？<br>第二种方式： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器</p><pre><code>//bean.xml文件里面的配置&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</code></pre><hr><pre><code>/** * jar包中的类，模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数） */public class InstanceFactory {    public IAccountService getAccountService(){        return new AccountServiceImpl();    }}</code></pre><p>第二种方式的要求工厂类instanceFactory，类名配好，然后下面那一行，有一个getAccountService方法和一个instanceFactory类。</p> <!-- 第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)    <bean id="accountService" class="com.itheima.factory.StaticFactory" factory-method="getAccountService"></bean>***    /**     * jar包中的类，模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）     */    public class StaticFactory {        public static IAccountService getAccountService(){            return new AccountServiceImpl();        }    }Bean的作用范围调整        bean的作用范围调整            bean标签的scope属性：                作用：用于指定bean的作用范围                取值： 常用的就是单例的和多例的                    singleton：单例的（默认值）                    prototype：多例的                    request：作用于web应用的请求范围                    session：作用于web应用的会话范围                    global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session        <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl" scope="prototype"></bean>那么global-session是什么：![](https://i.imgur.com/Xj13Dza.png)就比如开始有一个用户，他通过网址访问，然后过负载均衡，开始的时候在01,输入帐号密码，01里面的session就变成了1234，但是第二次她在访问06是空闲的，所以访问了06，但是这时候session还是在01里面，那么怎么办呢，就弄一个全局的globalsession，每次访问都放在global-session这个域里面就好了。Bean的对象的生命周期：     /**       单例对象                出生：当容器创建时对象出生                活着：只要容器还在，对象一直活着                死亡：容器销毁，对象消亡                总结：单例对象的生命周期和容器相同            多例对象                出生：当我们使用对象时spring框架为我们创建                活着：对象只要是在使用过程中就一直活着。                死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收     */需要借用一个属性：    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"          scope="prototype" init-method="init" destroy-method="destroy"></bean>    </beans>***    /**     * 账户的业务层实现类     */    public class AccountServiceImpl implements IAccountService {    public AccountServiceImpl() {        System.out.println("对象创建了");    }    public void  saveAccount(){        System.out.println("service中的saveAccount方法执行了。。。");    }    public void  init(){        System.out.println("对象初始化了。。。");    }    public void  destroy(){        System.out.println("对象销毁了。。。");    }}再说一下如果代码写成这样子：    ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");的话，会发现不能调用子类的方法，智能调用父类的方法，所以只能调用ApplicationContext的方法。在使用单例对象和多例对象的情况下，单例是刚执行这行方法就创建对象，多例是执行这个方法时候并不会创建，只有使用的时候才会创建。单例对象的死亡，就是容器destroy了，就关闭了，但是多例对象的死亡，如果对象长时间不用，并且没有别的对象引用的时候，由java的垃圾回收机制回收。下面是整个所有的代码：    package com.itheima.factory;    import com.itheima.service.IAccountService;    import com.itheima.service.impl.AccountServiceImpl;    /**     * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）     */    public class InstanceFactory {        public IAccountService getAccountService(){            return new AccountServiceImpl();        }    }***    package com.itheima.factory;    import com.itheima.service.IAccountService;    import com.itheima.service.impl.AccountServiceImpl;    /**     * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）     */    public class StaticFactory {        public static IAccountService getAccountService(){            return new AccountServiceImpl();        }    }***    package com.itheima.service;    /**     * 账户业务层的接口     */    public interface IAccountService {        /**         * 模拟保存账户         */        void saveAccount();    }***    package com.itheima.service.impl;    import com.itheima.service.IAccountService;    /**     * 账户的业务层实现类     */    public class AccountServiceImpl implements IAccountService {        public AccountServiceImpl() {            System.out.println("对象创建了");        }        public void  saveAccount(){            System.out.println("service中的saveAccount方法执行了。。。");        }        public void  init(){            System.out.println("对象初始化了。。。");        }        public void  destroy(){            System.out.println("对象销毁了。。。");        }    }***    package com.itheima.ui;    import com.itheima.service.IAccountService;    import org.springframework.context.support.ClassPathXmlApplicationContext;    /**     * 模拟一个表现层，用于调用业务层     */    public class Client {        /**         *         * @param args         */        public static void main(String[] args) {            //1.获取核心容器对象    //            ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");            //2.根据id获取Bean对象            IAccountService as  = (IAccountService)ac.getBean("accountService");            as.saveAccount();            //手动关闭容器            ac.close();        }    }***    <?xml version="1.0" encoding="UTF-8"?>    <beans xmlns="http://www.springframework.org/schema/beans"           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"           xsi:schemaLocation="http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans.xsd">        <!--把对象的创建交给spring来管理--><pre><code>    &lt;!--spring对bean的管理细节        1.创建bean的三种方式        2.bean对象的作用范围        3.bean对象的生命周期    --&gt;    &lt;!--创建Bean的三种方式 --&gt;    &lt;!-- 第一种方式：使用默认构造函数创建。            在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。            采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;    --&gt;    &lt;!-- 第二种方式： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）    &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;    --&gt;    &lt;!-- 第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;    --&gt;    &lt;!-- bean的作用范围调整        bean标签的scope属性：            作用：用于指定bean的作用范围            取值： 常用的就是单例的和多例的                singleton：单例的（默认值）                prototype：多例的                request：作用于web应用的请求范围                session：作用于web应用的会话范围                global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;    --&gt;    &lt;!-- bean对象的生命周期              单例对象                  出生：当容器创建时对象出生                  活着：只要容器还在，对象一直活着                  死亡：容器销毁，对象消亡                  总结：单例对象的生命周期和容器相同              多例对象                  出生：当我们使用对象时spring框架为我们创建                  活着：对象只要是在使用过程中就一直活着。                  死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收       --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;          scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><h1 id="Spring的依赖注入"><a href="#Spring的依赖注入" class="headerlink" title="Spring的依赖注入"></a>Spring的依赖注入</h1><h2 id="1、使用构造函数注入"><a href="#1、使用构造函数注入" class="headerlink" title="1、使用构造函数注入"></a>1、使用构造函数注入</h2><pre><code>&lt;!--spring中的依赖注入--&gt;&lt;!--    依赖注入：--&gt;&lt;!--        Dependency Injection--&gt;&lt;!--     IOC的作用：降低程序之间的依赖关系，但是没有消除。--&gt;&lt;!--    依赖关系的管理：--&gt;&lt;!--    以后都交给了spring来维护，--&gt;&lt;!--    在当前类中需要用到其他的对象，由spring为我们提供，我们只需要在配置文件中说明--&gt;&lt;!--    依赖关系的维护：就称之为依赖注入，--&gt;&lt;!--        能注入的数据有三种：--&gt;&lt;!--        基本类型和String、其他的bean类型（在配置文件中或者注解配置过的bean)、复杂类型|集合类型--&gt;&lt;!--        注入的方式有三种：--&gt;&lt;!--            第一种：使用构造函数提供--&gt;&lt;!--            第二种：使用set方法提供--&gt;&lt;!--            第三种：使用注解提供（明天内容）--&gt;</code></pre><hr><p>第一种方式：</p><pre><code>package com.itheima.service.impl;import com.itheima.service.IAccountService;import java.util.Date;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService {//如果是经常变化的数据，并不适合注入的方式，这里演示的3种类型，不考虑他们代表的意义，假设他们不经常变化适合注入    private String name;    private Integer age;    private Date birthday;    public AccountServiceImpl(String name, Integer age ,Date birthday){        this.name=name;        this.age=age;        this.birthday=birthday;    }    public void  saveAccount(){        System.out.println(&quot;service中的saveAccount方法执行了。。。&quot;);    }}</code></pre><hr><pre><code>// 但是像下面这样子注入的情况下，将test注入到上面实现类的构造函数里面，使用的是tpye方式，但是一旦构造函数中有2个以上的同类型，就难以判断是哪一个，这个是因为每个只有一种类型，所以可以解决。&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;test&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><hr><pre><code>  &lt;!--构造函数注入：    使用的标签:constructor-arg    标签出现的位置：bean标签的内部    标签中的属性        type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型        index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始        name：用于指定给构造函数中指定名称的参数赋值                                        常用的        =============以上三个用于指定给构造函数中哪个参数赋值===============================        value：用于提供基本类型和String类型的数据        ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象    优势：        在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。    弊端：        改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。--&gt;  &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;泰斯特&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;  &lt;!-- 配置一个日期对象 --&gt;&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</code></pre><h2 id="2、使用set方法注入"><a href="#2、使用set方法注入" class="headerlink" title="2、使用set方法注入"></a>2、使用set方法注入</h2><pre><code>&lt;!-- set方法注入                更常用的方式涉及的标签：property出现的位置：bean标签的内部标签的属性    name：用于指定注入时所调用的set方法名称    value：用于提供基本类型和String类型的数据    ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象优势：    创建对象时没有明确的限制，可以直接使用默认构造函数弊端： 对象是有可能set方法没有执行。（解释；有可能在调用AccountServiceImpl2这个类的时候已经用完了，所以set不了，每太明白。）--&gt;</code></pre><hr><pre><code>package com.itheima.service.impl;import com.itheima.service.IAccountService;import java.util.Date;/** * 账户的业务层实现类 */public class AccountServiceImpl2 implements IAccountService {    //如果是经常变化的数据，并不适合注入的方式，这里演示的3种类型，不考虑他们代表的意义，假设他们不经常变化适合注入    private String name;    private Integer age;    private Date birthday;    public void setName(String name) {        this.name = name;    }    public void setAge(Integer age) {        this.age = age;    }    public void setBirthday(Date birthday) {        this.birthday = birthday;    }    public void saveAccount() {        System.out.println(&quot;service中的saveAccount方法执行了。。。&quot;);    }}</code></pre><hr><pre><code> &lt;bean id=&quot;accountService2&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl2&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;TEST&quot; &gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置一个日期对象 --&gt;&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</code></pre><h2 id="复杂类型的注入"><a href="#复杂类型的注入" class="headerlink" title="复杂类型的注入"></a>复杂类型的注入</h2><pre><code>package com.itheima.service.impl;import com.itheima.service.IAccountService;import java.util.Arrays;import java.util.List;import java.util.Properties;import java.util.Set;import java.util.Map;/** * 账户的业务层实现类 */public class AccountServiceImpl3 implements IAccountService {//    数组、List集合、Set集合、Map集合、     private String[] myStrs;    private List&lt;String&gt; myList;    private Set&lt;String&gt; mySet;    private Map&lt;String,String&gt; myMap;    private Properties myProps;    public void setMyStrs(String[] myStrs) {        this.myStrs = myStrs;    }    public void setMyList(List&lt;String&gt; myList) {        this.myList = myList;    }    public void setMySet(Set&lt;String&gt; mySet) {        this.mySet = mySet;    }    public void setMyMap(Map&lt;String, String&gt; myMap) {        this.myMap = myMap;    }    public void setMyProps(Properties myProps) {        this.myProps = myProps;    }    public void  saveAccount(){        System.out.println(Arrays.toString(myStrs));        System.out.println(myList);        System.out.println(mySet);        System.out.println(myMap);        System.out.println(myProps);    }}</code></pre><hr><pre><code>&lt;!-- 复杂类型的注入/集合类型的注入       用于给List结构集合注入的标签：           list array set       用于个Map结构集合注入的标签:           map  props       结构相同，标签可以互换   --&gt;   &lt;bean id=&quot;accountService3&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl3&quot;&gt;       &lt;property name=&quot;myStrs&quot;&gt;           &lt;set&gt;               &lt;value&gt;AAA&lt;/value&gt;               &lt;value&gt;BBB&lt;/value&gt;               &lt;value&gt;CCC&lt;/value&gt;           &lt;/set&gt;       &lt;/property&gt;       &lt;property name=&quot;myList&quot;&gt;           &lt;array&gt;               &lt;value&gt;AAA&lt;/value&gt;               &lt;value&gt;BBB&lt;/value&gt;               &lt;value&gt;CCC&lt;/value&gt;           &lt;/array&gt;       &lt;/property&gt;       &lt;property name=&quot;mySet&quot;&gt;           &lt;list&gt;               &lt;value&gt;AAA&lt;/value&gt;               &lt;value&gt;BBB&lt;/value&gt;               &lt;value&gt;CCC&lt;/value&gt;           &lt;/list&gt;       &lt;/property&gt;       &lt;property name=&quot;myMap&quot;&gt;           &lt;props&gt;               &lt;prop key=&quot;testC&quot;&gt;ccc&lt;/prop&gt;               &lt;prop key=&quot;testD&quot;&gt;ddd&lt;/prop&gt;           &lt;/props&gt;       &lt;/property&gt;       &lt;property name=&quot;myProps&quot;&gt;           &lt;map&gt;               &lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;               &lt;entry key=&quot;testB&quot;&gt;                   &lt;value&gt;BBB&lt;/value&gt;               &lt;/entry&gt;           &lt;/map&gt;       &lt;/property&gt;   &lt;/bean&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-bean的三种创建细节和生命周期&quot;&gt;&lt;a href=&quot;#Spring-bean的三种创建细节和生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring bean的三种创建细节和生命周期&quot;&gt;&lt;/a&gt;Spring bean的三种创建细
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://erichunn.github.io/2019/09/21/VUE%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://erichunn.github.io/2019/09/21/VUE第一天/</id>
    <published>2019-09-21T12:52:25.900Z</published>
    <updated>2019-09-21T15:01:38.921Z</updated>
    
    <content type="html"><![CDATA[<p>1.Vue概述<br>2.Vue快速入门<br>3.Vue语法：<br>插值表达式<br>事件绑定<br>数据显示<br>逻辑判断和循环输出<br>4.Vue生命周期<br> 8个声明周期的执行点<br>        4个基本<br>        4个特殊<br>5.axios的ajax异步请求<br>        他和jquery的ajax比较相似<br>6.综合案例<br>        实现用户的查询列表和更新操作</p><p><img src="https://i.imgur.com/IyiqAsl.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Vue概述&lt;br&gt;2.Vue快速入门&lt;br&gt;3.Vue语法：&lt;br&gt;插值表达式&lt;br&gt;事件绑定&lt;br&gt;数据显示&lt;br&gt;逻辑判断和循环输出&lt;br&gt;4.Vue生命周期&lt;br&gt; 8个声明周期的执行点&lt;br&gt;        4个基本&lt;br&gt;        4个特殊&lt;br&gt;5.a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://erichunn.github.io/2019/09/18/Spring%E7%AC%94%E8%AE%B0/Spring%E7%AC%AC%E4%B8%8003.Spring%E7%9A%84%20IOC%20%E5%92%8C%20DI/"/>
    <id>http://erichunn.github.io/2019/09/18/Spring笔记/Spring第一03.Spring的 IOC 和 DI/</id>
    <published>2019-09-18T12:09:30.792Z</published>
    <updated>2019-09-18T12:37:05.120Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/wHM9KVT.png" alt=""></p><p>应用APP直接跟资源联系他们之间是必然联系，笑出不掉，很难应用独立，或者资源独立</p><p><img src="https://i.imgur.com/lGvrhOe.png" alt=""></p><p>这种通过APP联系工厂获得资源也就是所说的IOC控制反转。</p><p><img src="https://i.imgur.com/WcKZNOX.png" alt=""></p><p><img src="https://i.imgur.com/ng3fx2M.png" alt=""></p><p>在</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wHM9KVT.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;应用APP直接跟资源联系他们之间是必然联系，笑出不掉，很难应用独立，或者资源独立&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://erichunn.github.io/2019/09/17/Spring%E7%AC%94%E8%AE%B0/Spring%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%A8%8B%E5%BA%8F%E9%97%B4%E8%80%A6%E5%90%88/"/>
    <id>http://erichunn.github.io/2019/09/17/Spring笔记/Spring第一天程序间耦合/</id>
    <published>2019-09-17T14:32:26.724Z</published>
    <updated>2019-09-17T14:32:18.355Z</updated>
    
    <content type="html"><![CDATA[<p>一般不定义service层和dao层的类属性成员，因为一旦是单例对象的话就很容易每次调用的时候都修改掉他。对象创建多次，执行效率没有单例对象高。<br>工厂模式的解耦的升级版，我的理解是，在service层和controller层每次都需要一个下一层的对象，那么这个时候怎么办呢，就需要实例化一个对象，但是由于一直实例化对象不好，所以要通过写xml文件或者properties文件来写上service层的位置和dao层的位置，每次使用的时候就读取这个文件，然后通过getclassloader的getResourceAsStream来读取里面的文件，把这个存入到InputStream里面，在通过props.load(in)来加载这个放到props里面，在映射这个对象的时候，就是在工厂类里面来做这个事情的，然后通过while循环拿到props里面的每一个Key，然后在通过getProperty方法获取到Key对应的Propertiy，这个就是类全限定名路径，然后在通过Class.forName(beanPath).newInstance()来通过反射创建一个类。下面是一个工厂类。</p><pre><code>import java.io.InputStream;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import java.util.Properties;/** * @Description 一个创建bean对象的工厂 * Bean在英语中是：有可重用组件的意思。 * java bena不等于实体类。javabean的范围大于实体类。 * JavaBean:用Java语言编写的可重用组件 * &lt;p&gt; * 他就是创建我们的service和dao对象的 * 1、需要一个配置文件来配置我们的service和dao * 配置内容：唯一标志=全限定类名，(keyvalue) * 2、通过读取配置文件中配置的内容，反射创建对象 * &lt;p&gt; * 配置文件可以是xml也可以是Properties； * @Author TT Hun * @Data 2019/9/16 22:19 */public class BeanFactory {    //    读取properties文件。//    定义一个properties对象    private static Properties props;    //定义一个map，用于存放我们要创建的对象，我们把它称之为容器，是因为如果一个对象长时间不用的话垃圾回收机制就会把他回收    private static Map&lt;String, Object&gt; beans;//    使用静态代码块为Properties 对象赋值    static {        try {//    实例化对象            props = new Properties();//    不要采用如下的方式来New这一个对象，因为里面一旦写了src地址在编译期就没了，然后如果是写的绝对地址C盘，D盘的话也没了所以//    不用以下的方式//        InputStream in = new InputStream();//    获取Proerties文件的流对象//    所以这个地方我们使用类加载器来获取，里面的resource的路径会成为根路径下的一个文件。            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);            props.load(in);//            实例化容器            beans = new HashMap&lt;String, Object&gt;();//            取出来配置文件中所有的Key，keys返回的是一个枚举类型            Enumeration keys = props.keys();//            遍历枚举            while (keys.hasMoreElements()) {//      取出来每个key                String key = keys.nextElement().toString();//                根据Key获取value                String beanPath = props.getProperty(key);//                反射创建对象                Object value = Class.forName(beanPath).newInstance();//                把Key和value存入容器之中                beans.put(key, value);            }        } catch (Exception e) {//     这个地方一旦读取Properties失败后面的也就都失败了，所以这里面就可以抛出一个初始化异常，这个异常本质上也是一个error            throw new ExceptionInInitializerError(&quot;初始化properties失败程序不能执行&quot;);        }    }    /*根据benad的名称获取对象，此时已经是单例模式了*/        public static Object getBean(String beanName) {        return beans.get(beanName);    }////    /*根据bena的名称获取bean的对象*///    public static Object getBean(String beanName) {//        Object bean = null;//        try {//            String beanPath = props.getProperty(beanName);//            bean = Class.forName(beanPath).newInstance();//        } catch (Exception e) {//            e.printStackTrace();//        }//        return bean;//    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般不定义service层和dao层的类属性成员，因为一旦是单例对象的话就很容易每次调用的时候都修改掉他。对象创建多次，执行效率没有单例对象高。&lt;br&gt;工厂模式的解耦的升级版，我的理解是，在service层和controller层每次都需要一个下一层的对象，那么这个时候怎么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://erichunn.github.io/2019/09/17/Spring%E7%AC%94%E8%AE%B0/Spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://erichunn.github.io/2019/09/17/Spring笔记/Spring第一天/</id>
    <published>2019-09-17T13:15:45.189Z</published>
    <updated>2019-09-25T14:36:22.044Z</updated>
    
    <content type="html"><![CDATA[<p>一般不定义service层和dao层的类属性成员，因为一旦是单例对象的话就很容易每次调用的时候都修改掉他。对象创建多次，执行效率没有单例对象高。</p><p>工厂模式的解耦的升级版，我的理解是，在service层和controller层每次都需要一个下一层的对象，那么这个时候怎么办呢，就需要实例化一个对象，但是由于一直实例化对象不好，所以要通过写xml文件或者properties文件来写上service层的位置和dao层的位置，每次使用的时候就读取这个文件，然后通过getclassloader的getResourceAsStream来读取里面的文件，把这个存入到InputStream里面，在通过props.load(in)来加载这个放到props里面，在映射这个对象的时候，就是在工厂类里面来做这个事情的，然后通过while循环拿到props里面的每一个Key，然后在通过getProperty方法获取到Key对应的Propertiy，这个就是类全限定名路径，然后在通过Class.forName(beanPath).newInstance()来通过反射创建一个类。下面是一个工厂类。</p><pre><code>import java.io.InputStream;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import java.util.Properties;/** * @Description 一个创建bean对象的工厂 * Bean在英语中是：有可重用组件的意思。 * java bena不等于实体类。javabean的范围大于实体类。 * JavaBean:用Java语言编写的可重用组件 * &lt;p&gt; * 他就是创建我们的service和dao对象的 * 1、需要一个配置文件来配置我们的service和dao * 配置内容：唯一标志=全限定类名，(keyvalue) * 2、通过读取配置文件中配置的内容，反射创建对象 * &lt;p&gt; * 配置文件可以是xml也可以是Properties； * @Author TT Hun * @Data 2019/9/16 22:19 */public class BeanFactory {    //    读取properties文件。//    定义一个properties对象    private static Properties props;    //定义一个map，用于存放我们要创建的对象，我们把它称之为容器，是因为如果一个对象长时间不用的话垃圾回收机制就会把他回收    private static Map&lt;String, Object&gt; beans;//    使用静态代码块为Properties 对象赋值    static {        try {//    实例化对象            props = new Properties();//    不要采用如下的方式来New这一个对象，因为里面一旦写了src地址在编译期就没了，然后如果是写的绝对地址C盘，D盘的话也没了所以//    不用以下的方式//        InputStream in = new InputStream();//    获取Proerties文件的流对象//    所以这个地方我们使用类加载器来获取，里面的resource的路径会成为根路径下的一个文件。            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);            props.load(in);//            实例化容器            beans = new HashMap&lt;String, Object&gt;();//            取出来配置文件中所有的Key，keys返回的是一个枚举类型            Enumeration keys = props.keys();//            遍历枚举            while (keys.hasMoreElements()) {//      取出来每个key                String key = keys.nextElement().toString();//                根据Key获取value                String beanPath = props.getProperty(key);//                反射创建对象                Object value = Class.forName(beanPath).newInstance();//                把Key和value存入容器之中                beans.put(key, value);            }        } catch (Exception e) {//     这个地方一旦读取Properties失败后面的也就都失败了，所以这里面就可以抛出一个初始化异常，这个异常本质上也是一个error            throw new ExceptionInInitializerError(&quot;初始化properties失败程序不能执行&quot;);        }    }    /*根据benad的名称获取对象，此时已经是单例模式了*/        public static Object getBean(String beanName) {        return beans.get(beanName);    }////    /*根据bena的名称获取bean的对象*///    public static Object getBean(String beanName) {//        Object bean = null;//        try {//            String beanPath = props.getProperty(beanName);//            bean = Class.forName(beanPath).newInstance();//        } catch (Exception e) {//            e.printStackTrace();//        }//        return bean;//    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般不定义service层和dao层的类属性成员，因为一旦是单例对象的话就很容易每次调用的时候都修改掉他。对象创建多次，执行效率没有单例对象高。&lt;/p&gt;
&lt;p&gt;工厂模式的解耦的升级版，我的理解是，在service层和controller层每次都需要一个下一层的对象，那么这个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://erichunn.github.io/2019/09/12/Spark%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>http://erichunn.github.io/2019/09/12/Spark第二天/</id>
    <published>2019-09-12T12:37:10.115Z</published>
    <updated>2019-09-13T15:31:35.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><pre><code>通用性。</code></pre><h2 id="Spark模块"><a href="#Spark模块" class="headerlink" title="Spark模块"></a>Spark模块</h2><pre><code>Spark Core            //核心库Spark SQL            //SQLSpark Streaming        //准实时计算。Spark MLlib            //机器学习库Spark graph            //图计算</code></pre><h2 id="Spark集群运行"><a href="#Spark集群运行" class="headerlink" title="Spark集群运行"></a>Spark集群运行</h2><pre><code>1.local            //本地模式2.standalone    //独立模式3.yarn            //yarn模式4.mesos            //mesos</code></pre><h2 id="start-all-sh"><a href="#start-all-sh" class="headerlink" title="start-all.sh"></a>start-all.sh</h2><pre><code>start-master.sh    //RPC端口 7077start-slave.sh    spark://s201:7077</code></pre><h2 id="webui"><a href="#webui" class="headerlink" title="webui"></a>webui</h2><pre><code>http://s201:8080</code></pre><h2 id="添加针对scala文件的编译插件"><a href="#添加针对scala文件的编译插件" class="headerlink" title="添加针对scala文件的编译插件"></a>添加针对scala文件的编译插件</h2><p>在IDEA的settings里面没有设置自动编译的情况下，需要记入scala编译插件，所以打包不含scala的类。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.it18zhang&lt;/groupId&gt;    &lt;artifactId&gt;SparkDemo1&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;                &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;recompileMode&gt;incremental&lt;/recompileMode&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;goals&gt;                            &lt;goal&gt;compile&lt;/goal&gt;                            &lt;goal&gt;testCompile&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;            &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;            &lt;version&gt;2.1.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>C:\Users\Administrator.m2\repository\net<br>C:\Users\Administrator.m2\repository\net\alchim31\maven...</p><h2 id="SparkContext"><a href="#SparkContext" class="headerlink" title="SparkContext:"></a>SparkContext:</h2><pre><code>Spark集群的连接。主要入口点。SparkConf = new ();conf.setApp(&quot;&quot;)conf.setMaster(&quot;local&quot;) ;sc = new SparkContext(conf);//RDD : Resilient distributed dataset,弹性分布式数据集。val rdd1 = sc.textFile(&quot;d:/scala/test.txt&quot;);val rdd2 = rdd1.flatMap(line=&gt;line.split(&quot; &quot;));val rdd3 = rdd2.map(word=&gt;(word,1));val rdd4 = rdd3.reduceByKey(_ + _) ;val list = rdd4.collect()list.foreach(e=&gt;println(e));//sc.textFile(&quot;d:/scala&quot;).flatMap(_.split(&quot; &quot;)).map((_1)).reduceByKey(_ + _).collect().foreach(println)</code></pre><h2 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h2><pre><code>基于hadoop的mr，扩展MR模型高效使用MR模型，内存型集群计算，提高app处理速度。</code></pre><h2 id="spark特点"><a href="#spark特点" class="headerlink" title="spark特点"></a>spark特点</h2><pre><code>速度:在内存中存储中间结果。支持多种语言.内置了80+的算子.高级分析:MR，SQL/ Streamming /mllib / graph</code></pre><p>spark模块<br>    core        //通用执行引擎，提供内存计算和对外部数据集的引用。<br>    SQL            //构建在core之上，引入新的抽象SchemaRDD，提供了结构化和半结构化支持。</p><pre><code>Streaming    //小批量计算，用的是RDD.MLlib        //机器学习库。core在。Graphx        //图计算。</code></pre><h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD:"></a>RDD:</h2><pre><code>是spark的基本数据结构，是不可变数据集。RDD中的数据集进行逻辑分区，每个分区可以单独在集群节点进行计算。可以包含任何java,scala，python和自定义类型。RDD是只读的记录分区集合。RDD具有容错机制。创建RDD方式，一、并行化一个现有集合。hadoop 花费90%时间用户rw。、但是也不一定，如果是一次ｍｒ可能就不进入到磁盘里面，如果多次ｍｒ肯定进入到磁盘里面了。要等到数据都写入才可以，收到磁盘Ｉｏ影响严重内存处理计算。在job间进行数据共享。内存的IO速率高于网络和disk的10 ~ 100之间。内部包含5个主要属性-----------------------1.分区列表2.针对每个split的计算函数。3.对其他rdd的依赖列表4.可选，如果是KeyValueRDD的话，可以带分区类。5.可选，首选块位置列表(hdfs block location);//默认并发度下面从下往上面看是sc.textFile的源码过程这边确定一下，这个textFile里面的defaultMinPartitions指的是分区个数。然后在代码里面conf.setMaster(&quot;local[2]&quot;)这个里面的2指的才是线程个数才是并发度。这个线程就类似于我们完全分布下的节点local.backend.defaultParallelism() = scheduler.conf.getInt(&quot;spark.default.parallelism&quot;, totalCores)taskScheduler.defaultParallelism = backend.defaultParallelism()sc.defaultParallelism =...; taskScheduler.defaultParallelismdefaultMinPartitions = math.min(defaultParallelism, 2)sc.textFile(path,defaultMinPartitions)            //1,2</code></pre><p>先说一下mapreduce里面的Map和reduce可以和spark里面的Map和reduce相结合看一下：</p><p>Map过程：并行读取文本，对读取的单词进行map操作，每个词都以&lt;key,value&gt;形式生成。</p><pre><code>　　一个有三行文本的文件进行MapReduce操作。　　读取第一行Hello World Bye World ，分割单词形成Map。　　&lt;Hello,1&gt; &lt;World,1&gt; &lt;Bye,1&gt; &lt;World,1&gt;　　读取第二行Hello Hadoop Bye Hadoop ，分割单词形成Map。　　&lt;Hello,1&gt; &lt;Hadoop,1&gt; &lt;Bye,1&gt; &lt;Hadoop,1&gt;　　读取第三行Bye Hadoop Hello Hadoop，分割单词形成Map。　　&lt;Bye,1&gt; &lt;Hadoop,1&gt; &lt;Hello,1&gt; &lt;Hadoop,1&gt;</code></pre><p>Reduce操作是对map的结果进行排序，合并，最后得出词频。<br>我的理解：</p><pre><code>　　经过进一步处理(combiner),将形成的Map根据相同的key组合成value数组。　　&lt;Bye,1,1,1&gt; &lt;Hadoop,1,1,1,1&gt; &lt;Hello,1,1,1&gt; &lt;World,1,1&gt;　　循环执行Reduce(K,V[])，分别统计每个单词出现的次数。　　&lt;Bye,3&gt; &lt;Hadoop,4&gt; &lt;Hello,3&gt; &lt;World,2&gt;</code></pre><h2 id="RDD变换"><a href="#RDD变换" class="headerlink" title="RDD变换"></a>RDD变换</h2><pre><code>返回指向新rdd的指针，在rdd之间创建依赖关系。每个rdd都有计算函数和指向父RDD的指针。map()                                    //对每个元素进行变换，应用变换函数                                        //(T)=&gt;Vfilter()                                //过滤器,(T)=&gt;BooleanflatMap()                                //压扁,T =&gt; TraversableOnce[U]mapPartitions()                            //对每个分区进行应用变换，输入的Iterator,返回新的迭代器，可以对分区进行函数处理。                                        //Iterator&lt;T&gt; =&gt; Iterator&lt;U&gt;mapPartitionsWithIndex(func)            //同上，(Int, Iterator&lt;T&gt;) =&gt; Iterator&lt;U&gt;sample(withReplacement, fraction, seed)    //采样返回采样的RDD子集。                                        //withReplacement 元素是否可以多次采样.                                        //fraction : 期望采样数量.[0,1]union()                                    //类似于mysql union操作。                                        //select * from persons where id &lt; 10                                         //union select * from id persons where id &gt; 29 ;intersection                            //交集,提取两个rdd中都含有的元素。distinct([numTasks]))                    //去重,去除重复的元素。groupByKey()                            //(K,V) =&gt; (K,Iterable&lt;V&gt;)reduceByKey(*)                            //按key聚合。 aggregateByKey(zeroValue)(seqOp, combOp, [numTasks])                                        //按照key进行聚合key:String U:Int = 0sortByKey                                //排序join(otherDataset, [numTasks])            //连接,(K,V).join(K,W) =&gt;(K,(V,W)) cogroup                                    //协分组                                        //(K,V).cogroup(K,W) =&gt;(K,(Iterable&lt;V&gt;,Iterable&lt;!-- &lt;W&gt; --&gt;)) cartesian(otherDataset)                    //笛卡尔积,RR[T] RDD[U] =&gt; RDD[(T,U)]pipe                                    //将rdd的元素传递给脚本或者命令，执行结果返回形成新的RDDcoalesce(numPartitions)                    //减少分区repartition                                //可增可减repartitionAndSortWithinPartitions(partitioner)                                        //再分区并在分区内进行排序</code></pre><h2 id="RDD-Action"><a href="#RDD-Action" class="headerlink" title="RDD Action"></a>RDD Action</h2><pre><code>collect()                                //收集rdd元素形成数组.count()                                    //统计rdd元素的个数reduce()                                //聚合,返回一个值。first                                    //取出第一个元素take(1)take                                    //takeSample (withReplacement,num, [seed])takeOrdered(n, [ordering])saveAsTextFile(path)                    //保存到文件saveAsSequenceFile(path)                //保存成序列文件saveAsObjectFile(path) (Java and Scala)countByKey()                            //按照key,统计每个key下value的个数.</code></pre><h2 id="spark集成hadoop-ha"><a href="#spark集成hadoop-ha" class="headerlink" title="spark集成hadoop ha"></a>spark集成hadoop ha</h2><pre><code>1.复制core-site.xml + hdfs-site.xml到spark/conf目录下2.分发文件到spark所有work节点3.启动spark集群4.启动spark-shell,连接spark集群上    $&gt;spark-shell --master spark://s201:7077    $scala&gt;sc.textFile(&quot;hdfs://mycluster/user/centos/test.txt&quot;).collect();    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spark&quot;&gt;&lt;a href=&quot;#Spark&quot; class=&quot;headerlink&quot; title=&quot;Spark&quot;&gt;&lt;/a&gt;Spark&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;通用性。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Spark模块&quot;&gt;&lt;a href=&quot;#Spark
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://erichunn.github.io/2019/09/11/Mybatis%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>http://erichunn.github.io/2019/09/11/Mybatis第二天/</id>
    <published>2019-09-11T13:32:10.533Z</published>
    <updated>2019-09-11T13:34:19.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/CduGMIo.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CduGMIo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://erichunn.github.io/2019/09/10/Mybatis%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://erichunn.github.io/2019/09/10/Mybatis第一天/</id>
    <published>2019-09-10T07:05:48.373Z</published>
    <updated>2019-09-10T15:17:50.540Z</updated>
    
    <content type="html"><![CDATA[<p>mybatis框架<br>共四天<br>第一天：mybatis入门<br>    mybatis的概述<br>    mybatis的环境搭建<br>    mybatis入门案例<br>    自定义mybatis框架（主要的目的是为了让大家了解mybatis中执行细节）<br>第二天：mybatis基本使用<br>    mybatis的单表crud操作<br>    mybatis的参数和返回值<br>    mybatis的dao编写<br>    mybatis配置的细节<br>        几个标签的使用<br>第三天：mybatis的深入和多表<br>    mybatis的连接池<br>    mybatis的事务控制及设计的方法<br>    mybatis的多表查询<br>        一对多（多对一）<br>        多对多<br>第四天：mybatis的缓存和注解开发<br>    mybatis中的加载时机（查询的时机）<br>    mybatis中的一级缓存和二级缓存<br>    mybatis的注解开发<br>        单表CRUD</p><pre><code>多表查询</code></pre><hr><p>1、什么是框架？<br>    它是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题。<br>    使用框架的好处：<br>        框架封装了很多的细节，使开发者可以使用极简的方式实现功能。大大提高开发效率。<br>2、三层架构<br>    表现层：<br>        是用于展示数据的<br>    业务层：<br>        是处理业务需求<br>    持久层：<br>        是和数据库交互的<br>3、持久层技术解决方案<br>    JDBC技术：<br>        Connection<br>        PreparedStatement<br>        ResultSet<br>    Spring的JdbcTemplate：<br>        Spring中对jdbc的简单封装<br>    Apache的DBUtils：<br>        它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装</p><pre><code>以上这些都不是框架    JDBC是规范    Spring的JdbcTemplate和Apache的DBUtils都只是工具类</code></pre><p>4、mybatis的概述<br>    mybatis是一个持久层框架，用java编写的。<br>    它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程<br>    它使用了ORM思想实现了结果集的封装。</p><pre><code>ORM：    Object Relational Mappging 对象关系映射    简单的说：        就是把数据库表和实体类及实体类的属性对应起来        让我们可以操作实体类就实现操作数据库表。        user            User        id            userId        user_name        userName今天我们需要做到    实体类中的属性和数据库表的字段名称保持一致。        user            User        id            id        user_name        user_name</code></pre><p>5、mybatis的入门<br>    mybatis的环境搭建<br>        第一步：创建maven工程并导入坐标<br>        第二步：创建实体类和dao的接口<br>        第三步：创建Mybatis的主配置文件<br>                SqlMapConifg.xml<br>        第四步：创建映射配置文件<br>                IUserDao.xml<br>    环境搭建的注意事项：<br>        第一个：创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。<br>            在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper<br>            所以：IUserDao 和 IUserMapper是一样的<br>        第二个：在idea中创建目录的时候，它和包是不一样的<br>            包在创建时：com.itheima.dao它是三级结构<br>            目录在创建时：com.itheima.dao是一级目录<br>        第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同<br>        第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名<br>        第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p><pre><code>    当我们遵从了第三，四，五点之后，我们在开发中就无须再写dao的实现类。mybatis的入门案例    第一步：读取配置文件    第二步：创建SqlSessionFactory工厂    第三步：创建SqlSession    第四步：创建Dao接口的代理对象    第五步：执行dao中的方法    第六步：释放资源    注意事项：        不要忘记在映射配置中告知mybatis要封装到哪个实体类中        配置的方式：指定实体类的全限定类名    mybatis基于注解的入门案例：        把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句        同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。明确：    我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。    不管使用XML还是注解配置。    但是Mybatis它是支持写dao实现类的。</code></pre><p>6、自定义Mybatis的分析：<br>    mybatis在使用代理dao的方式实现增删改查时做什么事呢？<br>        只有两件事：<br>            第一：创建代理对象<br>            第二：在代理对象中调用selectList</p><pre><code>自定义mybatis能通过入门案例看到类    class Resources    class SqlSessionFactoryBuilder    interface SqlSessionFactory    interface SqlSession</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mybatis框架&lt;br&gt;共四天&lt;br&gt;第一天：mybatis入门&lt;br&gt;    mybatis的概述&lt;br&gt;    mybatis的环境搭建&lt;br&gt;    mybatis入门案例&lt;br&gt;    自定义mybatis框架（主要的目的是为了让大家了解mybatis中执行细节）
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://erichunn.github.io/2019/09/07/Spark%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://erichunn.github.io/2019/09/07/Spark第一天/</id>
    <published>2019-09-07T08:22:05.593Z</published>
    <updated>2019-09-09T14:59:34.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><pre><code>集群计算。并行计算。</code></pre><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><pre><code>并发执行。</code></pre><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><pre><code>Lightning-fast cluster computing。快如闪电的集群计算。大规模快速通用的计算引擎。速度:    比hadoop 100x,磁盘计算快10x使用:    java / Scala /R /python        提供80+算子(操作符)，容易构建并行应用。通用:    组合SQL ，流计算 + 复杂分析。运行：    Hadoop, Mesos, standalone, or in the cloud,local.</code></pre><h2 id="Spark模块"><a href="#Spark模块" class="headerlink" title="Spark模块"></a>Spark模块</h2><pre><code>Spark core        //核心模块Spark SQL        //SQLSpark Streaming    //流计算Spark MLlib        //机器学习Spark graph        //图计算DAG        //direct acycle graph,有向无环图。</code></pre><h2 id="安装Spark"><a href="#安装Spark" class="headerlink" title="安装Spark"></a>安装Spark</h2><pre><code>1.下载spark-2.1.0-bin-hadoop2.7.tgz    ..2.解压    ..3.环境变量    [/etc/profile]    SPARK_HOME=/soft/spark    PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin    [source]    $&gt;source /etc/profile4.验证spark    $&gt;cd /soft/spark    $&gt;./spark-shell5.webui    http://s201:4040/</code></pre><h2 id="体验spark"><a href="#体验spark" class="headerlink" title="体验spark"></a>体验spark</h2><pre><code>0.sc    SparkContext，Spark程序的入口点，封装了整个spark运行环境的信息。1.进入spark-shell    $&gt;spark-shell    $scala&gt;sc</code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><pre><code>[SparkContext]    Spark程序的入口点，封装了整个spark运行环境的信息。[RDD]    resilient distributed dataset,弹性分布式数据集。等价于集合。</code></pre><h2 id="spark实现word-count"><a href="#spark实现word-count" class="headerlink" title="spark实现word count"></a>spark实现word count</h2><pre><code>//加载文本文件,以换行符方式切割文本.Array(hello  world2,hello world2 ,...)val rdd1 = sc.textFile(&quot;/home/centos/test.txt&quot;);//单词统计1$scala&gt;val rdd1 = sc.textFile(&quot;/home/centos/test.txt&quot;)$scala&gt;val rdd2 = rdd1.flatMap(line=&gt;line.split(&quot; &quot;))$scala&gt;val rdd3 = rdd2.map(word = &gt; (word,1))$scala&gt;val rdd4 = rdd3.reduceByKey(_ + _)$scala&gt;rdd4.collect//单词统计2sc.textFile(&quot;/home/centos/test.txt&quot;).flatMap(_.split(&quot; &quot;)).map((_,1)).reduceByKey(_ + _).collect//统计所有含有wor字样到单词个数。filter//过滤单词sc.textFile(&quot;/home/centos/test.txt&quot;).flatMap(_.split(&quot; &quot;)).filter(_.contains(&quot;wor&quot;)).map((_,1)).reduceByKey(_ + _).collect</code></pre><p>[API]<br>    SparkContext:<br>        Spark功能的主要入口点。代表到Spark集群的连接，可以创建RDD、累加器和广播变量.<br>        每个JVM只能激活一个SparkContext对象，在创建sc之前需要stop掉active的sc。</p><pre><code>SparkConf:    spark配置对象，设置Spark应用各种参数，kv形式。</code></pre><h2 id="编写scala程序，引入spark类库，完成wordcount"><a href="#编写scala程序，引入spark类库，完成wordcount" class="headerlink" title="编写scala程序，引入spark类库，完成wordcount"></a>编写scala程序，引入spark类库，完成wordcount</h2><pre><code>1.创建Scala模块,并添加pom.xml    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;             xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;        &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;        &lt;groupId&gt;com.it18zhang&lt;/groupId&gt;        &lt;artifactId&gt;SparkDemo1&lt;/artifactId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;                &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;                &lt;version&gt;2.1.0&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/project&gt;2.编写scala文件    import org.apache.spark.{SparkConf, SparkContext}    /**      * Created by Administrator on 2017/4/20.      */    object WordCountDemo {        def main(args: Array[String]): Unit = {            //创建Spark配置对象            val conf = new SparkConf();            conf.setAppName(&quot;WordCountSpark&quot;)            //设置master属性            conf.setMaster(&quot;local&quot;) ;            //通过conf创建sc            val sc = new SparkContext(conf);            //加载文本文件            val rdd1 = sc.textFile(&quot;d:/scala/test.txt&quot;);            //压扁            val rdd2 = rdd1.flatMap(line =&gt; line.split(&quot; &quot;)) ;            //映射w =&gt; (w,1)            val rdd3 = rdd2.map((_,1))            val rdd4 = rdd3.reduceByKey(_ + _)            val r = rdd4.collect()            r.foreach(println)        }    }</code></pre><h2 id="java版单词统计"><a href="#java版单词统计" class="headerlink" title="java版单词统计"></a>java版单词统计</h2><pre><code>import org.apache.spark.SparkConf;import org.apache.spark.SparkContext;import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.api.java.JavaSparkContext;import org.apache.spark.api.java.function.FlatMapFunction;import org.apache.spark.api.java.function.Function2;import org.apache.spark.api.java.function.PairFunction;import scala.Tuple2;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * java版 */public class WordCountJava2 {    public static void main(String[] args) {        //创建SparkConf对象        SparkConf conf = new SparkConf();        conf.setAppName(&quot;WordCountJava2&quot;);        conf.setMaster(&quot;local&quot;);        //创建java sc        JavaSparkContext sc = new JavaSparkContext(conf);        //加载文本文件        JavaRDD&lt;String&gt; rdd1 = sc.textFile(&quot;d:/scala//test.txt&quot;);        //压扁        JavaRDD&lt;String&gt; rdd2 = rdd1.flatMap(new FlatMapFunction&lt;String, String&gt;() {            public Iterator&lt;String&gt; call(String s) throws Exception {                List&lt;String&gt; list = new ArrayList&lt;String&gt;();                String[] arr = s.split(&quot; &quot;);                for(String ss :arr){                    list.add(ss);                }                return list.iterator();            }        });        //映射,word -&gt; (word,1)        JavaPairRDD&lt;String,Integer&gt; rdd3 = rdd2.mapToPair(new PairFunction&lt;String, String, Integer&gt;() {            public Tuple2&lt;String, Integer&gt; call(String s) throws Exception {                return new Tuple2&lt;String, Integer&gt;(s,1);            }        });        //reduce化简        JavaPairRDD&lt;String,Integer&gt; rdd4 = rdd3.reduceByKey(new Function2&lt;Integer, Integer, Integer&gt;() {            public Integer call(Integer v1, Integer v2) throws Exception {                return v1 + v2;            }        });        //        List&lt;Tuple2&lt;String,Integer&gt;&gt; list = rdd4.collect();        for(Tuple2&lt;String, Integer&gt; t : list){            System.out.println(t._1() + &quot; : &quot; + t._2());        }    }}</code></pre><p>Spark2.1.0最新版是基于Scala2.11.8版本，因此安装scala2.11.8版本，</p><h2 id="否则如果基于2-12-0版本编译会出现找不到包的问题。"><a href="#否则如果基于2-12-0版本编译会出现找不到包的问题。" class="headerlink" title="否则如果基于2.12.0版本编译会出现找不到包的问题。"></a>否则如果基于2.12.0版本编译会出现找不到包的问题。</h2><pre><code>1.卸载原来的scala.2.重新安装scala2.11.8版本3.配置idea的全局库    project settings -&gt; global library -&gt; 删除原来的scala sdk    project settings -&gt; global library -&gt; 添加sdk -&gt; browser -&gt; 定位scala安装目录 -&gt;选中scala-compiler.jar +                                                                                         scala-library.jar +                                                                                         scala-reflect.jar4.在模块中添加scala sdk 2.11.8版本5.重新编译项目 -&gt; 导入jar -&gt;丢到集群运行。</code></pre><h2 id="提交作业到spark集群运行"><a href="#提交作业到spark集群运行" class="headerlink" title="提交作业到spark集群运行"></a>提交作业到spark集群运行</h2><pre><code>1.导出jar包2.spark-submit提交命令运行job    //Scala版本    $&gt;spark-submit --master local --name MyWordCount --class com.it18zhang.spark.scala.WordCountScala SparkDemo1-1.0-SNAPSHOT.jar /home/centos/test.txt    //java版    $&gt;spark-submit --master local --name MyWordCount --class com.it18zhang.spark.java.WordCountJava SparkDemo1-1.0-SNAPSHOT.jar /home/centos/test.txt</code></pre><h2 id="Spark集群模式"><a href="#Spark集群模式" class="headerlink" title="Spark集群模式"></a>Spark集群模式</h2><pre><code>1.local    nothing!    spark-shell --master local;        //默认2.standalone    独立模式。    a)复制spark安装目录到其他几个主机    b)配置其他主机的所有环境变量        [/etc/profile]        SPARK_HOME        PATH    c)配置master节点的slaves        [/soft/spark/conf/slaves]文件中添加下面的        s202        s203        s204    d)启动spark集群，和hadoop一样，但是要指定目录下即可。这个是独立模式和没有关系        /soft/spark/sbin/start-all.sh    e)查看进程        $&gt;xcall.jps jps            master        //s201            worker        //s202            worker        //s203            worker        //s204    e)webui，然后验证webui，8080端口。本地模式是4040端口        http://s201:8080/</code></pre><h2 id="提交作业jar到完全分布式spark集群"><a href="#提交作业jar到完全分布式spark集群" class="headerlink" title="提交作业jar到完全分布式spark集群"></a>提交作业jar到完全分布式spark集群</h2><pre><code>1.需要启动hadoop集群(只需要hdfs，是standalone模式，不需要yarn调度)    $&gt;start-dfs.sh2.put文件到hdfs.3.运行spark-submit    $&gt;spark-submit                 --master spark://s201:7077                 --name MyWordCount                 --class com.it18zhang.spark.scala.WordCountScala                 SparkDemo1-1.0-SNAPSHOT.jar                 hdfs://s201:8020/user/centos/test.txt</code></pre><h2 id="脚本分析"><a href="#脚本分析" class="headerlink" title="脚本分析"></a>脚本分析</h2><pre><code>[start-all.sh]    sbin/spark-config.sh    sbin/spark-master.sh        //启动master进程    sbin/spark-slaves.sh        //启动worker进程[start-master.sh]    sbin/spark-config.sh    org.apache.spark.deploy.master.Master    spark-daemon.sh start org.apache.spark.deploy.master.Master --host --port --webui-port ...[spark-slaves.sh]    sbin/spark-config.sh    slaves.sh                //主要循环这个文件conf/slaves[slaves.sh]    for conf/slaves{        ssh host start-slave.sh ...    }[start-slave.sh]</code></pre><p>先找到这个work类<br>        CLASS=”org.apache.spark.deploy.worker.Worker”<br>        sbin/spark-config.sh 走这个配置<br>        for ((  .. )) ; do<br>            start_instance $(( 1 + $i )) “$@”<br>        done </p><pre><code>$&gt;cd /soft/spark/sbin$&gt;./stop-all.sh                //停掉整个spark集群.$&gt;./start-master.sh            //停掉整个spark集群.$&gt;./start-master.sh            //启动master节点$&gt;./start-slaves.sh            //启动所有worker节点从s204里面启动某一个slave ./start-slave.sh spark://s201:7077对上面几个命令了解可以通过 start-master.sh --help来查询，其他类似</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并行&quot;&gt;&lt;a href=&quot;#并行&quot; class=&quot;headerlink&quot; title=&quot;并行&quot;&gt;&lt;/a&gt;并行&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;集群计算。
并行计算。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
</feed>
